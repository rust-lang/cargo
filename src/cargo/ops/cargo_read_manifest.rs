use std::path::Path;

use crate::core::{EitherManifest, Package, SourceId};
use crate::util::GlobalContext;
use crate::util::errors::CargoResult;
use crate::util::toml::{read_cargo_generated_manifest, read_manifest};
use tracing::trace;

pub fn read_package(
    path: &Path,
    source_id: SourceId,
    gctx: &GlobalContext,
) -> CargoResult<Package> {
    trace!(
        "read_package; path={}; source-id={}",
        path.display(),
        source_id
    );
    let manifest = read_manifest(path, source_id, gctx)?;
    let manifest = match manifest {
        EitherManifest::Real(manifest) => manifest,
        EitherManifest::Virtual(..) => anyhow::bail!(
            "found a virtual manifest at `{}` instead of a package \
             manifest",
            path.display()
        ),
    };

    Ok(Package::new(manifest, path))
}

/// Reads a cargo-generated package manifest.
///
/// This is for reading packages that were generated by cargo itself
/// (e.g., during package verification), which may contain internal-only
/// fields like `registry-index`.
pub fn read_cargo_generated_package(
    path: &Path,
    source_id: SourceId,
    gctx: &GlobalContext,
) -> CargoResult<Package> {
    trace!(
        "read_cargo_generated_package; path={}; source-id={}",
        path.display(),
        source_id
    );
    let manifest = read_cargo_generated_manifest(path, source_id, gctx)?;
    let manifest = match manifest {
        EitherManifest::Real(manifest) => manifest,
        EitherManifest::Virtual(..) => anyhow::bail!(
            "found a virtual manifest at `{}` instead of a package \
             manifest",
            path.display()
        ),
    };

    Ok(Package::new(manifest, path))
}
