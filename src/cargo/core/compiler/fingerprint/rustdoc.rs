use std::path::Path;

use anyhow::Context as _;
use cargo_util::paths;
use serde::Deserialize;
use serde::Serialize;

use crate::CargoResult;
use crate::core::compiler::BuildRunner;
use crate::core::compiler::CompileKind;

/// Structure used to deal with Rustdoc fingerprinting
///
/// This is important because the `.js`/`.html` & `.css` files
/// that are generated by Rustc don't have any versioning yet
/// (see <https://github.com/rust-lang/cargo/issues/8461>).
/// Therefore, we can end up with weird bugs and behaviours
/// if we mix different versions of these files.
///
/// We need to make sure that if there were any previous docs already compiled,
/// they were compiled with the same Rustc version that we're currently using.
/// Otherwise we must remove the `doc/` folder and compile again forcing a rebuild.
#[derive(Debug, Serialize, Deserialize)]
pub struct RustDocFingerprint {
    /// `rustc -vV` verbose version output.
    pub rustc_vv: String,
}

impl RustDocFingerprint {
    /// Checks whether the latest version of rustc used to compile this workspace's docs
    /// was the same as the one is currently being used in this `cargo doc` call.
    ///
    /// In case it's not,
    /// it takes care of removing the `<build-dir>/doc/` folder
    /// as well as overwriting the rustdoc fingerprint info.
    /// This is to guarantee that we won't end up with mixed versions of the `js/html/css` files
    /// which `rustdoc` autogenerates without any versioning.
    ///
    /// Each requested target platform maintains its own fingerprint file.
    /// That is, if you run `cargo doc` and then `cargo doc --target wasm32-wasip1`,
    /// you will have two separate fingerprint files:
    ///
    /// * `<build-dir>/.rustdoc_fingerprint.json` for host
    /// * `<build-dir>/wasm32-wasip1/.rustdoc_fingerprint.json`
    pub fn check_rustdoc_fingerprint(build_runner: &BuildRunner<'_, '_>) -> CargoResult<()> {
        if build_runner
            .bcx
            .gctx
            .cli_unstable()
            .skip_rustdoc_fingerprint
        {
            return Ok(());
        }
        let new_fingerprint = RustDocFingerprint {
            rustc_vv: build_runner.bcx.rustc().verbose_version.clone(),
        };

        for kind in &build_runner.bcx.build_config.requested_kinds {
            check_fingerprint(build_runner, &new_fingerprint, *kind)?;
        }

        Ok(())
    }
}

/// Checks rustdoc fingerprint file for a given [`CompileKind`].
fn check_fingerprint(
    build_runner: &BuildRunner<'_, '_>,
    new_fingerprint: &RustDocFingerprint,
    kind: CompileKind,
) -> CargoResult<()> {
    let fingerprint_path = build_runner
        .files()
        .layout(kind)
        .build_dir()
        .root()
        .join(".rustdoc_fingerprint.json");

    let write_fingerprint = || -> CargoResult<()> {
        paths::write(&fingerprint_path, serde_json::to_string(new_fingerprint)?)
    };

    let Ok(rustdoc_data) = paths::read(&fingerprint_path) else {
        // If the fingerprint does not exist, do not clear out the doc
        // directories. Otherwise this ran into problems where projects
        // like bootstrap were creating the doc directory before running
        // `cargo doc` in a way that deleting it would break it.
        return write_fingerprint();
    };

    match serde_json::from_str::<RustDocFingerprint>(&rustdoc_data) {
        Ok(on_disk_fingerprint) => {
            if on_disk_fingerprint.rustc_vv == new_fingerprint.rustc_vv {
                return Ok(());
            } else {
                tracing::debug!(
                    "doc fingerprint changed:\noriginal:\n{}\nnew:\n{}",
                    on_disk_fingerprint.rustc_vv,
                    new_fingerprint.rustc_vv
                );
            }
        }
        Err(e) => {
            tracing::debug!("could not deserialize {:?}: {}", fingerprint_path, e);
        }
    };
    // Fingerprint does not match, delete the doc directories and write a new fingerprint.
    tracing::debug!(
        "fingerprint {:?} mismatch, clearing doc directories",
        fingerprint_path
    );
    let doc_dir = build_runner
        .files()
        .layout(kind)
        .artifact_dir()
        .expect("artifact-dir was not locked")
        .doc();
    if doc_dir.exists() {
        clean_doc(doc_dir)?;
    }

    write_fingerprint()?;

    Ok(())
}

fn clean_doc(path: &Path) -> CargoResult<()> {
    let entries = path
        .read_dir()
        .with_context(|| format!("failed to read directory `{}`", path.display()))?;
    for entry in entries {
        let entry = entry?;
        // Don't remove hidden files. Rustdoc does not create them,
        // but the user might have.
        if entry
            .file_name()
            .to_str()
            .map_or(false, |name| name.starts_with('.'))
        {
            continue;
        }
        let path = entry.path();
        if entry.file_type()?.is_dir() {
            paths::remove_dir_all(path)?;
        } else {
            paths::remove_file(path)?;
        }
    }
    Ok(())
}
