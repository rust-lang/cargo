<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Frequently Asked Questions - Cargo Documentation</title>

    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css">
<link rel="stylesheet" type="text/css" href="stylesheets/all.css">
<link rel="stylesheet" type="text/css" href="stylesheets/prism.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>

<a href='https://github.com/rust-lang/cargo' class='fork-me'>
  <img src='images/forkme.png'/>
</a>

<div id="header">
    <a href='https://crates.io' class='logo'>
        <img id="logo" height=100 width=100 src='images/Cargo-Logo-Small.png'/>
    </a>
    <a href="index.html">
        <h1>CARGO</h1>
    </a>

    <div class="search">
        <form action="https://crates.io/search"
              method="GET">
            <input name="q" class="search" placeholder="Search crates" type="text"/>
        </form>
    </div>

    <div class="nav">
        <a href='https://crates.io/crates'>Browse All Crates</a>

        <span class='sep'>|</span>

        <div class="dropdown-container">
            <button class="dropdown">
                Documentation
                <span class="arrow"></span>
            </button>
            <ul id="current-user-links" class="dropdown" data-bindattr-503="503">
                <li><a href='index.html'>Getting Started</a></li>
                <li><a href='guide.html'>Guide</a></li>
                <li><a href='crates-io.html'>Using crates.io</a></li>
                <li><a href='faq.html'>FAQ</a></li>
                <li><a href='manifest.html'>Manifest Format</a></li>
                <li><a href='build-script.html'>Build Scripts</a></li>
                <li><a href='config.html'>Configuration</a></li>
                <li><a href='pkgid-spec.html'>Package ID specs</a></li>
            </ul>
        </div>
    </div>
</div>

<main>


    <h1 class="title">Frequently Asked Questions - Cargo Documentation</h1>
    
<h1 id="is-the-plan-to-use-github-as-a-package-repository?" class='section-header'><a
                           href="#is-the-plan-to-use-github-as-a-package-repository?">Is the plan to use Github as a package repository?</a></h1>
<p>No. The plan for Cargo is to use crates.io, like npm or Rubygems do with
npmjs.org and rubygems.org.</p>

<p>We plan to support git repositories as a source of packages forever,
because they can be used for early development and temporary patches,
even when people use the registry as the primary source of packages.</p>

<p>At the moment, the Rust team is still making regular changes to the
language, and the Rust project recommends using nightly builds. This
means that for now, package authors make regular changes in order to
track the latest Rust. This makes downloading the latest <code>master</code> from
Github the best approach to getting packages at the current point in the
community&#39;s lifecycle.</p>

<h1 id="why-build-crates.io-rather-than-use-github-as-a-registry?" class='section-header'><a
                           href="#why-build-crates.io-rather-than-use-github-as-a-registry?">Why build crates.io rather than use Github as a registry?</a></h1>
<p>We think that it&#39;s very important to support multiple ways to download
packages, including downloading from Github and copying packages into
your project itself.</p>

<p>That said, we think that crates.io offers a number of important benefits, and
will likely become the primary way that people download packages in Cargo.</p>

<p>For precedent, both Node.js&#39;s <a href="https://www.npmjs.org">npm</a> and Ruby&#39;s <a href="https://bundler.io">bundler</a> support both a
central registry model as well as a Git-based model, and most packages
are downloaded through the registry in those ecosystems, with an
important minority of packages making use of git-based packages.</p>

<p>Some of the advantages that make a central registry popular in other
languages include:</p>

<ul>
<li><strong>Discoverability</strong>. A central registry provides an easy place to look
for existing packages. Combined with tagging, this also makes it
possible for a registry to provide ecosystem-wide information, such as a
list of the most popular or most-depended-on packages.</li>
<li><strong>Speed</strong>. A central registry makes it possible to easily fetch just
the metadata for packages quickly and efficiently, and then to
efficiently download just the published package, and not other bloat
that happens to exist in the repository. This adds up to a significant
improvement in the speed of dependency resolution and fetching. As
dependency graphs scale up, downloading all of the git repositories bogs
down fast. Also remember that not everybody has a high-speed,
low-latency Internet connection.</li>
</ul>

<h1 id="why-build-crates.io-before-rust-1.0?" class='section-header'><a
                           href="#why-build-crates.io-before-rust-1.0?">Why build crates.io before Rust 1.0?</a></h1>
<p>One of Rust&#39;s greatest strengths is its thriving community, and Cargo is a key
tool in helping it grow even further. A central repository like crates.io has
always been part of Cargo&#39;s vision and by building it before Rust 1.0 we&#39;re able
to flesh out bugs and streamline the experience for new 1.0 users.</p>

<p>Crates may have difficulty publishing to the registry in the interim due to the
language changing, invalidating all previously published versions. This is a
transitionary pain which will not exist once Rust 1.0 is released.</p>

<h1 id="will-cargo-work-with-c-code-(or-other-languages)?" class='section-header'><a
                           href="#will-cargo-work-with-c-code-(or-other-languages)?">Will Cargo work with C code (or other languages)?</a></h1>
<p>Yes!</p>

<p>Cargo handles compiling Rust code, but we know that many Rust projects
link against C code. We also know that there are decades of tooling
built up around compiling languages other than Rust.</p>

<p>Our solution: Cargo allows a package to <a href="build-script.html">specify a script</a>
(written in Rust) to run before invoking <code>rustc</code>. Rust is leveraged to
implement platform-specific configuration and refactor out common build
functionality among packages.</p>

<h1 id="can-cargo-be-used-inside-of-make-(or-ninja,-or-...)" class='section-header'><a
                           href="#can-cargo-be-used-inside-of-make-(or-ninja,-or-...)">Can Cargo be used inside of <code>make</code> (or <code>ninja</code>, or ...)</a></h1>
<p>Indeed. While we intend Cargo to be useful as a standalone way to
compile Rust projects at the top-level, we know that some people will
want to invoke Cargo from other build tools.</p>

<p>We have designed Cargo to work well in those contexts, paying attention
to things like error codes and machine-readable output modes. We still
have some work to do on those fronts, but using Cargo in the context of
conventional scripts is something we designed for from the beginning and
will continue to prioritize.</p>

<h1 id="does-cargo-handle-multi-platform-projects-or-cross-compilation?" class='section-header'><a
                           href="#does-cargo-handle-multi-platform-projects-or-cross-compilation?">Does Cargo handle multi-platform projects or cross-compilation?</a></h1>
<p>Rust itself provides facilities for configuring sections of code based
on the platform. Cargo also supports <a href="manifest.html#the-%5Bdependencies.*%5D-sections">platform-specific
dependencies</a>, and we plan to support more per-platform
configuration in <code>Cargo.toml</code> in the future.</p>

<p>In the longer-term, we&#39;re looking at ways to conveniently cross-compile
projects using Cargo.</p>

<h1 id="does-cargo-support-environments,-like-production-or-test?" class='section-header'><a
                           href="#does-cargo-support-environments,-like-production-or-test?">Does Cargo support environments, like <code>production</code> or <code>test</code>?</a></h1>
<p>We support environments through the use of <a href="manifest.html#the-%5Bprofile.*%5D-sections">profiles</a> to support:</p>

<ul>
<li>environment-specific flags (like <code>-g --opt-level=0</code> for development
and <code>--opt-level=3</code> for production).</li>
<li>environment-specific dependencies (like <code>hamcrest</code> for test assertions).</li>
<li>environment-specific <code>#[cfg]</code></li>
<li>a <code>cargo test</code> command</li>
</ul>

<h1 id="does-cargo-work-on-windows?" class='section-header'><a
                           href="#does-cargo-work-on-windows?">Does Cargo work on Windows?</a></h1>
<p>Yes!</p>

<p>All commits to Cargo are required to pass the local test suite on Windows.
If, however, you find a Windows issue, we consider it a bug, so <a href="https://github.com/rust-lang/cargo/issues">please file an
issue</a>.</p>

<h1 id="why-do-binaries-have-cargo.lock-in-version-control,-but-not-libraries?" class='section-header'><a
                           href="#why-do-binaries-have-cargo.lock-in-version-control,-but-not-libraries?">Why do binaries have <code>Cargo.lock</code> in version control, but not libraries?</a></h1>
<p>The purpose of a <code>Cargo.lock</code> is to describe the state of the world at the time
of a successful build. It is then used to provide deterministic builds across
whatever machine is building the project by ensuring that the exact same
dependencies are being compiled.</p>

<p>This property is most desirable from applications and projects which are at the
very end of the dependency chain (binaries). As a result, it is recommended that
all binaries check in their <code>Cargo.lock</code>.</p>

<p>For libraries the situation is somewhat different. A library is not only used by
the library developers, but also any downstream consumers of the library. Users
dependent on the library will not inspect the library&#39;s <code>Cargo.lock</code> (even if it
exists). This is precisely because a library should <strong>not</strong> be deterministically
recompiled for all users of the library.</p>

<p>If a library ends up being used transitively by several dependencies, it&#39;s
likely that just a single copy of the library is desired (based on semver
compatibility). If all libraries were to check in their <code>Cargo.lock</code>, then
multiple copies of the library would be used, and perhaps even a version
conflict.</p>

<p>In other words, libraries specify semver requirements for their dependencies but
cannot see the full picture. Only end products like binaries have a full
picture to decide what versions of dependencies should be used.</p>

<h1 id="why-cargo.toml?" class='section-header'><a
                           href="#why-cargo.toml?">Why <code>Cargo.toml</code>?</a></h1>
<p>As one of the most frequent interactions with Cargo, the question of why the
configuration file is named <code>Cargo.toml</code> arises from time to time. The leading
capital-<code>C</code> was chosen to ensure that the manifest was grouped with other
similar configuration files in directory listings. Sorting files often puts
capital letters before lowercase letters, ensuring files like <code>Makefile</code> and
<code>Cargo.toml</code> are placed together. The trailing <code>.toml</code> was chosen to emphasize
the fact that the file is in the <a href="https://github.com/toml-lang/toml">TOML configuration
format</a>.</p>

<p>Cargo does not allow other names such as <code>cargo.toml</code> or <code>Cargofile</code> to
emphasize the ease of how a Cargo repository can be identified. An option of
many possible names has historically led to confusion where one case was handled
but others were accidentally forgotten.</p>

    <script type="text/javascript">
        window.playgroundUrl = "";
    </script>
    </main>
<footer>
<a href='index.html'>Install</a>
<span class='sep'>|</span>
<a href='index.html'>Getting Started</a>
<span class='sep'>|</span>
<a href='guide.html'>Guide</a>
</footer>

<script type='text/javascript' src='javascripts/prism.js'></script>
<script type='text/javascript' src='javascripts/all.js'></script>


</body>
</html>