//! Tests for weak-dep-features.

use std::fmt::Write;

use crate::prelude::*;
use cargo_test_support::compare::assert_e2e;
use cargo_test_support::registry::{Dependency, Package, RegistryBuilder};
use cargo_test_support::str;
use cargo_test_support::{project, publish};

use super::features2::switch_to_resolver_2;

// Helper to create lib.rs files that check features.
fn require(enabled_features: &[&str], disabled_features: &[&str]) -> String {
    let mut s = String::new();
    writeln!(s, "#![allow(unexpected_cfgs)]").unwrap();
    for feature in enabled_features {
        writeln!(s, "#[cfg(not(feature=\"{feature}\"))] compile_error!(\"expected feature {feature} to be enabled\");",
            feature=feature).unwrap();
    }
    for feature in disabled_features {
        writeln!(s, "#[cfg(feature=\"{feature}\")] compile_error!(\"did not expect feature {feature} to be enabled\");",
            feature=feature).unwrap();
    }
    s
}

#[cargo_test]
fn simple() {
    Package::new("bar", "1.0.0")
        .feature("feat", &[])
        .file("src/lib.rs", &require(&["feat"], &[]))
        .publish();
    let p = project()
        .file(
            "Cargo.toml",
            r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                bar = { version = "1.0", optional = true }

                [features]
                f1 = ["bar?/feat"]
            "#,
        )
        .file("src/lib.rs", &require(&["f1"], &[]))
        .build();

    // It's a bit unfortunate that this has to download `bar`, but avoiding
    // that is extremely difficult.
    p.cargo("check --features f1")
        .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 1 package to latest compatible version
[DOWNLOADING] crates ...
[DOWNLOADED] bar v1.0.0 (registry `dummy-registry`)
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
        .run();

    p.cargo("check --features f1,bar")
        .with_stderr_data(str![[r#"
[CHECKING] bar v1.0.0
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
        .run();
}

#[cargo_test]
fn deferred() {
    // A complex chain that requires deferring enabling the feature due to
    // another dependency getting enabled.
    Package::new("the_feat", "1.0.0").publish();
    Package::new("bar", "1.0.0")
        .add_dep(Dependency::new("the_feat", "1.0").optional(true))
        .feature("feat", &["the_feat"])
        .file("src/lib.rs", &require(&["feat"], &[]))
        .publish();
    Package::new("dep", "1.0.0")
        .add_dep(Dependency::new("bar", "1.0").optional(true))
        .feature("feat", &["bar?/feat"])
        .publish();
    Package::new("bar_activator", "1.0.0")
        .feature_dep("dep", "1.0", &["bar"])
        .publish();
    let p = project()
        .file(
            "Cargo.toml",
            r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                dep = { version = "1.0", features = ["feat"] }
                bar_activator = "1.0"
            "#,
        )
        .file("src/lib.rs", "")
        .build();

    // the_feat is here
    p.cargo("check")
        .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 4 packages to latest compatible versions
[DOWNLOADING] crates ...
[DOWNLOADED] the_feat v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] dep v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar_activator v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar v1.0.0 (registry `dummy-registry`)
[CHECKING] the_feat v1.0.0
[CHECKING] bar v1.0.0
[CHECKING] dep v1.0.0
[CHECKING] bar_activator v1.0.0
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
        .run();

    assert_e2e().eq(
        p.read_lockfile(),
        str![[r##"
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "bar"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a5a94c9ce6fff510501b3eb79c27668885c7405e775c07ab1cba7fa34b924432"
dependencies = [
 "the_feat",
]

[[package]]
name = "bar_activator"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b18ddf303c71fcb159f91aeccb88122fe080b350e27ce14736e2bda997f3a44"
dependencies = [
 "dep",
]

[[package]]
name = "dep"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f76f7ff2ad7258f7049037ad54a8314d4dd7099f2c58bf2aac66b88dc4cf8c20"
dependencies = [
 "bar",
]

[[package]]
name = "foo"
version = "0.1.0"
dependencies = [
 "bar_activator",
 "dep",
]

[[package]]
name = "the_feat"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d56d4072c94494f3295832017ba6b37debdbf785084cfb596856e5380ea9cfb6"

"##]],
    );
    // Update to new lockfile version
    let lockfile = p.read_lockfile();
    let lockfile = lockfile.replace("version = 4", "version = 5");
    p.change_file("Cargo.lock", &lockfile);

    // the_feat is still here
    p.cargo("check -Znext-lockfile-bump")
        .masquerade_as_nightly_cargo(&["weak_dep_check"])
        .run();

    assert_e2e().eq(
        p.read_lockfile(),
        str![[r##"
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 5

[[package]]
name = "bar"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a5a94c9ce6fff510501b3eb79c27668885c7405e775c07ab1cba7fa34b924432"
dependencies = [
 "the_feat",
]

[[package]]
name = "bar_activator"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b18ddf303c71fcb159f91aeccb88122fe080b350e27ce14736e2bda997f3a44"
dependencies = [
 "dep",
]

[[package]]
name = "dep"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f76f7ff2ad7258f7049037ad54a8314d4dd7099f2c58bf2aac66b88dc4cf8c20"
dependencies = [
 "bar",
]

[[package]]
name = "foo"
version = "0.1.0"
dependencies = [
 "bar_activator",
 "dep",
]

[[package]]
name = "the_feat"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d56d4072c94494f3295832017ba6b37debdbf785084cfb596856e5380ea9cfb6"

"##]],
    );
}

#[cargo_test]
fn not_optional_dep() {
    // Attempt to use dep_name?/feat where dep_name is not optional.
    Package::new("dep", "1.0.0").feature("feat", &[]).publish();

    let p = project()
        .file(
            "Cargo.toml",
            r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                dep = "1.0"

                [features]
                feat = ["dep?/feat"]
            "#,
        )
        .file("src/lib.rs", "")
        .build();

    p.cargo("check")
        .with_status(101)
        .with_stderr_data(str![[r#"
[ERROR] failed to parse manifest at `[ROOT]/foo/Cargo.toml`

Caused by:
  feature `feat` includes `dep?/feat` with a `?`, but `dep` is not an optional dependency
  A non-optional dependency of the same name is defined; consider removing the `?` or changing the dependency to be optional

"#]])
        .run();
}

#[cargo_test]
fn optional_cli_syntax() {
    // --features bar?/feat
    Package::new("bar", "1.0.0")
        .feature("feat", &[])
        .file("src/lib.rs", &require(&["feat"], &[]))
        .publish();

    let p = project()
        .file(
            "Cargo.toml",
            r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                bar = { version = "1.0", optional = true }
            "#,
        )
        .file("src/lib.rs", "")
        .build();

    // Does not build bar.
    p.cargo("check --features bar?/feat")
        .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 1 package to latest compatible version
[DOWNLOADING] crates ...
[DOWNLOADED] bar v1.0.0 (registry `dummy-registry`)
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
        .run();

    // Builds bar.
    p.cargo("check --features bar?/feat,bar")
        .with_stderr_data(str![[r#"
[CHECKING] bar v1.0.0
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
        .run();

    eprintln!("check V2 resolver");
    switch_to_resolver_2(&p);
    p.build_dir().rm_rf();
    // Does not build bar.
    p.cargo("check --features bar?/feat")
        .with_stderr_data(str![[r#"
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
        .run();

    // Builds bar.
    p.cargo("check --features bar?/feat,bar")
        .with_stderr_data(str![[r#"
[CHECKING] bar v1.0.0
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
        .run();
}

#[cargo_test]
fn required_features() {
    // required-features doesn't allow ?
    Package::new("bar", "1.0.0").feature("feat", &[]).publish();

    let p = project()
        .file(
            "Cargo.toml",
            r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                bar = { version = "1.0", optional = true }

                [[bin]]
                name = "foo"
                required-features = ["bar?/feat"]
            "#,
        )
        .file("src/main.rs", "fn main() {}")
        .build();

    p.cargo("check")
        .with_status(101)
        .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 1 package to latest compatible version
[ERROR] invalid feature `bar?/feat` in required-features of target `foo`: optional dependency with `?` is not allowed in required-features

"#]])
        .run();
}

#[cargo_test]
fn weak_with_host_decouple() {
    // weak-dep-features with new resolver
    //
    // foo v0.1.0
    // └── common v1.0.0
    //     └── bar v1.0.0        <-- does not have `feat` enabled
    // [build-dependencies]
    // └── bar_activator v1.0.0
    //     └── common v1.0.0
    //         └── bar v1.0.0    <-- does have `feat` enabled
    Package::new("bar", "1.0.0")
        .feature("feat", &[])
        .file(
            "src/lib.rs",
            r#"
                pub fn feat() -> bool {
                    cfg!(feature = "feat")
                }
            "#,
        )
        .publish();

    Package::new("common", "1.0.0")
        .add_dep(Dependency::new("bar", "1.0").optional(true))
        .feature("feat", &["bar?/feat"])
        .file(
            "src/lib.rs",
            r#"
                #[cfg(feature = "bar")]
                pub fn feat() -> bool { bar::feat() }
                #[cfg(not(feature = "bar"))]
                pub fn feat() -> bool { false }
            "#,
        )
        .publish();

    Package::new("bar_activator", "1.0.0")
        .feature_dep("common", "1.0", &["bar", "feat"])
        .file(
            "src/lib.rs",
            r#"
                pub fn feat() -> bool {
                    common::feat()
                }
            "#,
        )
        .publish();

    let p = project()
        .file(
            "Cargo.toml",
            r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"
                resolver = "2"

                [dependencies]
                common = { version = "1.0", features = ["feat"] }

                [build-dependencies]
                bar_activator = "1.0"
            "#,
        )
        .file(
            "src/main.rs",
            r#"
                fn main() {
                    assert!(!common::feat());
                }
            "#,
        )
        .file(
            "build.rs",
            r#"
                fn main() {
                    assert!(bar_activator::feat());
                }
            "#,
        )
        .build();

    p.cargo("run")
        .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 3 packages to latest compatible versions
[DOWNLOADING] crates ...
[DOWNLOADED] common v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar_activator v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar v1.0.0 (registry `dummy-registry`)
[COMPILING] bar v1.0.0
[COMPILING] common v1.0.0
[COMPILING] bar_activator v1.0.0
[COMPILING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s
[RUNNING] `target/debug/foo[EXE]`

"#]])
        .run();
}

#[cargo_test]
fn weak_namespaced() {
    // Behavior with a dep: dependency.
    Package::new("the_feat", "1.0.0").publish();
    Package::new("bar", "1.0.0")
        .feature("feat", &["the_feat"])
        .add_dep(&Dependency::new("the_feat", "1.0.0").optional(true))
        .file("src/lib.rs", &require(&["feat"], &[]))
        .publish();
    let p = project()
        .file(
            "Cargo.toml",
            r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                bar = { version = "1.0", optional = true }

                [features]
                f1 = ["bar?/feat"]
                f2 = ["dep:bar"]
            "#,
        )
        .file("src/lib.rs", &require(&["f1"], &["f2", "bar"]))
        .build();

    p.cargo("check --features f1")
        .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 2 packages to latest compatible versions
[DOWNLOADING] crates ...
[DOWNLOADED] the_feat v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar v1.0.0 (registry `dummy-registry`)
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
        .run();

    p.cargo("tree -f")
        .arg("{p} feats:{f}")
        .with_stdout_data(str![[r#"
foo v0.1.0 ([ROOT]/foo) feats:

"#]])
        .run();

    p.cargo("tree --features f1 -f")
        .arg("{p} feats:{f}")
        .with_stdout_data(str![[r#"
foo v0.1.0 ([ROOT]/foo) feats:f1

"#]])
        .run();

    p.cargo("tree --features f1,f2 -f")
        .arg("{p} feats:{f}")
        .with_stdout_data(str![[r#"
foo v0.1.0 ([ROOT]/foo) feats:f1,f2
└── bar v1.0.0 feats:feat,the_feat
    └── the_feat v1.0.0 feats:

"#]])
        .run();

    // "bar" remains not-a-feature
    p.change_file("src/lib.rs", &require(&["f1", "f2"], &["bar"]));

    p.cargo("check --features f1,f2")
        .with_stderr_data(str![[r#"
[CHECKING] the_feat v1.0.0
[CHECKING] bar v1.0.0
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
        .run();
    // bar is here
    assert_e2e().eq(
        p.read_lockfile(),
        str![[r##"
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "bar"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ddeb3ce1dc21204e1cc3bc547e8c6f809ba91e862dd51fa95aa5183b5e73cd31"
dependencies = [
 "the_feat",
]

[[package]]
name = "foo"
version = "0.1.0"
dependencies = [
 "bar",
]

[[package]]
name = "the_feat"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d56d4072c94494f3295832017ba6b37debdbf785084cfb596856e5380ea9cfb6"

"##]],
    );

    // Update to new lockfile version
    let lockfile = p.read_lockfile();
    let lockfile = lockfile.replace("version = 4", "version = 5");
    p.change_file("Cargo.lock", &lockfile);

    // run f1; f1,f2 check
    p.change_file("src/lib.rs", &require(&["f1"], &["f2", "bar"]));
    p.cargo("check --features f1 -Znext-lockfile-bump")
        .masquerade_as_nightly_cargo(&["weak_dep_check"])
        .with_stderr_data(str![[r#"
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
        .run();

    p.change_file("src/lib.rs", &require(&["f1", "f2"], &["bar"]));
    p.cargo("check --features f1,f2 -Znext-lockfile-bump")
        .masquerade_as_nightly_cargo(&["weak_dep_check"])
        .with_stderr_data(str![[r#"
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
        .run();

    // list new dep tree
    p.cargo("tree -Znext-lockfile-bump -f")
        .masquerade_as_nightly_cargo(&["weak_dep_check"])
        .arg("{p} feats:{f}")
        .with_stdout_data(str![[r#"
foo v0.1.0 ([ROOT]/foo) feats:

"#]])
        .run();

    p.cargo("tree -Znext-lockfile-bump --features f1 -f")
        .masquerade_as_nightly_cargo(&["weak_dep_check"])
        .arg("{p} feats:{f}")
        .with_stdout_data(str![[r#"
foo v0.1.0 ([ROOT]/foo) feats:f1

"#]])
        .run();
    p.cargo("tree -Znext-lockfile-bump --features f1,f2 -f")
        .masquerade_as_nightly_cargo(&["weak_dep_check"])
        .arg("{p} feats:{f}")
        .with_stdout_data(str![[r#"
foo v0.1.0 ([ROOT]/foo) feats:f1,f2
└── bar v1.0.0 feats:feat,the_feat
    └── the_feat v1.0.0 feats:

"#]])
        .run();
    // bar remains
    assert_e2e().eq(
        p.read_lockfile(),
        str![[r##"
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 5

[[package]]
name = "bar"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ddeb3ce1dc21204e1cc3bc547e8c6f809ba91e862dd51fa95aa5183b5e73cd31"
dependencies = [
 "the_feat",
]

[[package]]
name = "foo"
version = "0.1.0"
dependencies = [
 "bar",
]

[[package]]
name = "the_feat"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d56d4072c94494f3295832017ba6b37debdbf785084cfb596856e5380ea9cfb6"

"##]],
    );
}

#[cargo_test]
fn tree() {
    Package::new("bar", "1.0.0")
        .feature("feat", &[])
        .file("src/lib.rs", &require(&["feat"], &[]))
        .publish();
    let p = project()
        .file(
            "Cargo.toml",
            r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                bar = { version = "1.0", optional = true }

                [features]
                f1 = ["bar?/feat"]
            "#,
        )
        .file("src/lib.rs", &require(&["f1"], &[]))
        .build();

    p.cargo("tree --features f1")
        .with_stdout_data(str![[r#"
foo v0.1.0 ([ROOT]/foo)

"#]])
        .run();

    p.cargo("tree --features f1,bar")
        .with_stdout_data(str![[r#"
foo v0.1.0 ([ROOT]/foo)
└── bar v1.0.0

"#]])
        .run();

    p.cargo("tree --features f1,bar -e features")
        .with_stdout_data(str![[r#"
foo v0.1.0 ([ROOT]/foo)
└── bar feature "default"
    └── bar v1.0.0

"#]])
        .run();

    p.cargo("tree --features f1,bar -e features -i bar")
        .with_stdout_data(str![[r#"
bar v1.0.0
├── bar feature "default"
│   └── foo v0.1.0 ([ROOT]/foo)
│       ├── foo feature "bar" (command-line)
│       ├── foo feature "default" (command-line)
│       └── foo feature "f1" (command-line)
└── bar feature "feat"
    └── foo feature "f1" (command-line)

"#]])
        .run();

    p.cargo("tree -e features --features bar?/feat")
        .with_stdout_data(str![[r#"
foo v0.1.0 ([ROOT]/foo)

"#]])
        .run();

    // This is a little strange in that it produces no output.
    // Maybe `cargo tree` should print a note about why?
    p.cargo("tree -e features -i bar --features bar?/feat")
        .with_stdout_data("")
        .run();

    p.cargo("tree -e features -i bar --features bar?/feat,bar")
        .with_stdout_data(str![[r#"
bar v1.0.0
├── bar feature "default"
│   └── foo v0.1.0 ([ROOT]/foo)
│       ├── foo feature "bar" (command-line)
│       └── foo feature "default" (command-line)
└── bar feature "feat" (command-line)

"#]])
        .run();
}

#[cargo_test]
fn publish() {
    let registry = RegistryBuilder::new().http_api().http_index().build();

    // Publish behavior with /? syntax.
    Package::new("bar", "1.0.0").feature("feat", &[]).publish();
    let p = project()
        .file(
            "Cargo.toml",
            r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"
                description = "foo"
                license = "MIT"
                homepage = "https://example.com/"

                [dependencies]
                bar = { version = "1.0", optional = true }

                [features]
                feat1 = []
                feat2 = ["bar?/feat"]
            "#,
        )
        .file("src/lib.rs", "")
        .build();

    p.cargo("publish")
        .replace_crates_io(registry.index_url())
        .with_stderr_data(str![[r#"
[UPDATING] crates.io index
[PACKAGING] foo v0.1.0 ([ROOT]/foo)
[UPDATING] crates.io index
[PACKAGED] 4 files, [FILE_SIZE]B ([FILE_SIZE]B compressed)
[VERIFYING] foo v0.1.0 ([ROOT]/foo)
[COMPILING] foo v0.1.0 ([ROOT]/foo/target/package/foo-0.1.0)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s
[UPLOADING] foo v0.1.0 ([ROOT]/foo)
[UPLOADED] foo v0.1.0 to registry `crates-io`
[NOTE] waiting for foo v0.1.0 to be available at registry `crates-io`
[HELP] you may press ctrl-c to skip waiting; the crate should be available shortly
[PUBLISHED] foo v0.1.0 at registry `crates-io`

"#]])
        .run();

    publish::validate_upload_with_contents(
        r#"
        {
          "authors": [],
          "badges": {},
          "categories": [],
          "deps": [
            {
              "default_features": true,
              "features": [],
              "kind": "normal",
              "name": "bar",
              "optional": true,
              "target": null,
              "version_req": "^1.0"
            }
          ],
          "description": "foo",
          "documentation": null,
          "features": {
            "feat1": [],
            "feat2": ["bar?/feat"]
          },
          "homepage": "https://example.com/",
          "keywords": [],
          "license": "MIT",
          "license_file": null,
          "links": null,
          "name": "foo",
          "readme": null,
          "readme_file": null,
          "repository": null,
          "rust_version": null,
          "vers": "0.1.0"
          }
        "#,
        "foo-0.1.0.crate",
        &["Cargo.toml", "Cargo.toml.orig", "src/lib.rs", "Cargo.lock"],
        [(
            "Cargo.toml",
            str![[r##"
# THIS FILE IS AUTOMATICALLY GENERATED BY CARGO
#
# When uploading crates to the registry Cargo will automatically
# "normalize" Cargo.toml files for maximal compatibility
# with all versions of Cargo and also rewrite `path` dependencies
# to registry (e.g., crates.io) dependencies.
#
# If you are reading this file be aware that the original Cargo.toml
# will likely look very different (and much more reasonable).
# See Cargo.toml.orig for the original contents.

[package]
edition = "2015"
name = "foo"
version = "0.1.0"
build = false
autolib = false
autobins = false
autoexamples = false
autotests = false
autobenches = false
description = "foo"
homepage = "https://example.com/"
readme = false
license = "MIT"

[features]
feat1 = []
feat2 = ["bar?/feat"]

[lib]
name = "foo"
path = "src/lib.rs"

[dependencies.bar]
version = "1.0"
optional = true

"##]],
        )],
    );
}

#[cargo_test]
fn disabled_weak_direct_dep() {
    // A weak direct dependency should be included in Cargo.lock,
    // even if disabled, and even if on lockfile version 5.
    Package::new("bar", "1.0.0")
        .feature("feat", &[])
        .file("src/lib.rs", &require(&["feat"], &[]))
        .publish();
    let p = project()
        .file(
            "Cargo.toml",
            r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                bar = { version = "1.0", optional = true }

                [features]
                f1 = ["bar?/feat"]
            "#,
        )
        .file("src/lib.rs", &require(&["f1"], &[]))
        .build();

    // bar is inside lockfile.
    p.cargo("check --features f1")
        .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 1 package to latest compatible version
[DOWNLOADING] crates ...
[DOWNLOADED] bar v1.0.0 (registry `dummy-registry`)
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
        .run();

    assert_e2e().eq(
        p.read_lockfile(),
        str![[r##"
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "bar"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "43c62587ef115a424e4cc7909efed3b58b1a2fe27855b47d476018ad296b4c5b"

[[package]]
name = "foo"
version = "0.1.0"
dependencies = [
 "bar",
]

"##]],
    );

    // Update to new lockfile version
    let lockfile = p.read_lockfile();
    let lockfile = lockfile.replace("version = 4", "version = 5");
    p.change_file("Cargo.lock", &lockfile);

    // bar is still there because it is a direct (optional) dependency.
    p.cargo("check -Znext-lockfile-bump --features f1")
        .masquerade_as_nightly_cargo(&["weak_dep_check"])
        .run();

    assert_e2e().eq(
        p.read_lockfile(),
        str![[r##"
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 5

[[package]]
name = "bar"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "43c62587ef115a424e4cc7909efed3b58b1a2fe27855b47d476018ad296b4c5b"

[[package]]
name = "foo"
version = "0.1.0"
dependencies = [
 "bar",
]

"##]],
    );
}

#[cargo_test]
fn disabled_weak_optional_deps() {
    // A weak dependency of a dependency should not be included in Cargo.lock,
    // at least on lockfile version 5.
    Package::new("bar", "1.0.0")
        .feature("feat", &[])
        .file("src/lib.rs", &require(&["feat"], &[]))
        .publish();
    Package::new("dep", "1.0.0")
        .add_dep(Dependency::new("bar", "1.0").optional(true))
        .feature("feat", &["bar?/feat"])
        .file("src/lib.rs", "")
        .publish();
    let p = project()
        .file(
            "Cargo.toml",
            r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                dep = { version = "1.0", features = ["feat"] }
            "#,
        )
        .file("src/lib.rs", "")
        .build();

    // bar is here
    p.cargo("check")
        .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 2 packages to latest compatible versions
[DOWNLOADING] crates ...
[DOWNLOADED] dep v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar v1.0.0 (registry `dummy-registry`)
[CHECKING] dep v1.0.0
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
        .run();

    assert_e2e().eq(
        p.read_lockfile(),
        str![[r##"
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "bar"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "43c62587ef115a424e4cc7909efed3b58b1a2fe27855b47d476018ad296b4c5b"

[[package]]
name = "dep"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f76f7ff2ad7258f7049037ad54a8314d4dd7099f2c58bf2aac66b88dc4cf8c20"
dependencies = [
 "bar",
]

[[package]]
name = "foo"
version = "0.1.0"
dependencies = [
 "dep",
]

"##]],
    );

    // Update to new lockfile version
    let lockfile = p.read_lockfile();
    let lockfile = lockfile.replace("version = 4", "version = 5");
    p.change_file("Cargo.lock", &lockfile);

    p.cargo("check -Znext-lockfile-bump --features dep/bar")
        .masquerade_as_nightly_cargo(&["weak_dep_check"])
        .run();
    // bar is gone
    assert_e2e().eq(
        p.read_lockfile(),
        str![[r##"
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 5

[[package]]
name = "dep"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f76f7ff2ad7258f7049037ad54a8314d4dd7099f2c58bf2aac66b88dc4cf8c20"

[[package]]
name = "foo"
version = "0.1.0"
dependencies = [
 "dep",
]

"##]],
    );
}

#[cargo_test]
fn weak_feats_requiring_renamed_dep() {
    Package::new("foo", "0.1.0").feature("feat", &[]).publish();
    Package::new("foo", "0.2.0").feature("feat", &[]).publish();
    Package::new("bar", "0.1.0")
        .add_dep(
            &Dependency::new("foo1", "0.1.0")
                .optional(true)
                .package("foo"),
        )
        .add_dep(
            &Dependency::new("foo2", "0.2.0")
                .optional(true)
                .package("foo"),
        )
        .feature("feat", &["foo1?/feat", "foo2?/feat"])
        .publish();

    let p = project()
        .file(
            "Cargo.toml",
            r#"
                [package]
                name = "test"
                version = "0.1.0"
                edition = "2015"
                authors = []

                [dependencies]
                bar = { version = "0.1.0", features = ["feat"] }
            "#,
        )
        .file("src/lib.rs", "")
        .build();

    // Both foo 0.1.0 and foo 0.2.0 included
    p.cargo("check")
        .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 3 packages to latest compatible versions
[DOWNLOADING] crates ...
[DOWNLOADED] foo v0.2.0 (registry `dummy-registry`)
[DOWNLOADED] foo v0.1.0 (registry `dummy-registry`)
[DOWNLOADED] bar v0.1.0 (registry `dummy-registry`)
[CHECKING] bar v0.1.0
[CHECKING] test v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
        .run();

    assert_e2e().eq(
        p.read_lockfile(),
        str![[r##"
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "bar"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df7c8e90704edb21cd66f631d30c9af1f687b65ebe1e4904d1ca3c038af859a4"
dependencies = [
 "foo 0.1.0",
 "foo 0.2.0",
]

[[package]]
name = "foo"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3fba04dcc0af057e23434bc1a5ccadedc7b6033529f4b20df06412844ac1247c"

[[package]]
name = "foo"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93e78d87ee35a304f7393b53b19eebaa528ea47dec0e87727b42fe759c3307ef"

[[package]]
name = "test"
version = "0.1.0"
dependencies = [
 "bar",
]

"##]],
    );

    // Update to new lockfile version
    let lockfile = p.read_lockfile();
    let lockfile = lockfile.replace("version = 4", "version = 5");
    p.change_file("Cargo.lock", &lockfile);

    // Both foo are gone
    p.cargo("check -Znext-lockfile-bump")
        .masquerade_as_nightly_cargo(&["weak_dep_check"])
        .run();

    assert_e2e().eq(
        p.read_lockfile(),
        str![[r##"
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 5

[[package]]
name = "bar"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df7c8e90704edb21cd66f631d30c9af1f687b65ebe1e4904d1ca3c038af859a4"

[[package]]
name = "test"
version = "0.1.0"
dependencies = [
 "bar",
]

"##]],
    );
}

#[cargo_test]
fn bad_weak_feat_within_one_package() {
    // they should be identical
    Package::new("foo", "0.1.0").feature("feat", &[]).publish();
    Package::new("foo", "0.2.0").feature("feat2", &[]).publish();
    Package::new("bar", "0.1.0")
        .add_dep(
            &Dependency::new("foo1", "0.1.0")
                .optional(true)
                .package("foo"),
        )
        .add_dep(
            &Dependency::new("foo2", "0.2.0")
                .optional(true)
                .package("foo"),
        )
        .feature("feat", &["foo1?/feat", "foo2?/feat"])
        .publish();

    let p = project()
        .file(
            "Cargo.toml",
            r#"
                [package]
                name = "test"
                version = "0.1.0"
                edition = "2015"
                authors = []

                [dependencies]
                bar = { version = "0.1.0", features = ["feat", "foo2"] }
            "#,
        )
        .file("src/lib.rs", "")
        .build();

    p.cargo("check")
        .with_status(101)
        .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for `foo`.
    ... required by package `bar v0.1.0`
    ... which satisfies dependency `bar = "^0.1.0"` of package `test v0.1.0 ([ROOT]/foo)`
versions that meet the requirements `^0.2.0` are: 0.2.0

package `bar` depends on `foo` with feature `feat` but `foo` does not have that feature.
 package `foo` does have feature `feat2`


failed to select a version for `foo` which could resolve this conflict

"#]])
        .run();

    // Update to new lockfile version
    p.change_file("Cargo.lock", "version = 5");

    p.cargo("check -Znext-lockfile-bump")
        .masquerade_as_nightly_cargo(&["weak_dep_check"])
        .with_status(101)
        .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for `foo`.
    ... required by package `bar v0.1.0`
    ... which satisfies dependency `bar = "^0.1.0"` of package `test v0.1.0 ([ROOT]/foo)`
versions that meet the requirements `^0.2.0` are: 0.2.0

package `bar` depends on `foo` with feature `feat` but `foo` does not have that feature.
 package `foo` does have feature `feat2`


failed to select a version for `foo` which could resolve this conflict

"#]])
        .run();
}

// here we start to check the order of resolver traversing dep tree
// that's done via adding candidates to deprioritize one package

// A -> bar_activator
// B -> feat_activator
// C -> bar_wrapper
macro_rules! quick_ordering {
    (C, $count:expr) => {
        for i in 0..$count {
            Package::new("bar_wrapper", format!("1.1.{i}").as_str())
                .add_dep(Dependency::new("bar", "1.0").optional(true))
                .feature("feat", &["bar?/the_feat"])
                .publish();
        }
    };
    (B, $count:expr) => {
        for i in 0..$count {
            Package::new("feat_activator", format!("1.1.{i}").as_str())
                .feature_dep("bar_wrapper", "1.1", &["feat"])
                .publish();
        }
    };
    (A, $count:expr) => {
        for i in 0..$count {
            Package::new("bar_activator", format!("1.1.{i}").as_str())
                .feature_dep("bar_wrapper", "1.1", &["bar"])
                .publish();
        }
    };
}

#[cargo_test]
fn order_check_baseline() {
    Package::new("the_feat", "1.0.0").publish();
    Package::new("bar", "1.0.0")
        .add_dep(Dependency::new("the_feat", "1.0").optional(true))
        .publish();
    quick_ordering!(A, 1);
    quick_ordering!(B, 1);
    quick_ordering!(C, 1);
    let p = project()
        .file(
            "Cargo.toml",
            r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
            "#,
        )
        .file("src/lib.rs", "")
        .build();

    p.cargo("check")
        .with_stderr_data(
            str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 5 packages to latest compatible versions
[DOWNLOADING] crates ...
[DOWNLOADED] the_feat v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] feat_activator v1.1.0 (registry `dummy-registry`)
[DOWNLOADED] bar_wrapper v1.1.0 (registry `dummy-registry`)
[DOWNLOADED] bar_activator v1.1.0 (registry `dummy-registry`)
[DOWNLOADED] bar v1.0.0 (registry `dummy-registry`)
[CHECKING] the_feat v1.0.0
[CHECKING] bar v1.0.0
[CHECKING] bar_wrapper v1.1.0
[CHECKING] bar_activator v1.1.0
[CHECKING] feat_activator v1.1.0
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]]
            .unordered(),
        )
        .run();

    // Update to new lockfile version
    p.change_file("Cargo.lock", "version = 5");

    p.cargo("check -Znext-lockfile-bump")
        .masquerade_as_nightly_cargo(&["weak_dep_check"])
        .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 5 packages to latest compatible versions
[ADDING] bar v1.0.0
[ADDING] bar_activator v1.1.0
[ADDING] bar_wrapper v1.1.0
[ADDING] feat_activator v1.1.0
[ADDING] the_feat v1.0.0
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
        .run();
}

mod missing_dependency {
    use super::*;

    #[cargo_test]
    fn missing_dependency_order_check() {
        Package::new("the_feat", "0.1.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.0").optional(true))
            .publish();
        quick_ordering!(A, 1);
        quick_ordering!(B, 1);
        quick_ordering!(C, 1);
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_status(101)
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for the requirement `the_feat = "^1.0"`
candidate versions found which didn't match: 0.1.0
location searched: `dummy-registry` index (which is replacing registry `crates-io`)
required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `bar_activator v1.1.0`
    ... which satisfies dependency `bar_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
perhaps a crate was updated and forgotten to be re-vendored?

"#]])
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .with_status(101)
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for the requirement `the_feat = "^1.0"`
candidate versions found which didn't match: 0.1.0
location searched: `dummy-registry` index (which is replacing registry `crates-io`)
required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `feat_activator v1.1.0`
    ... which satisfies dependency `feat_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
perhaps a crate was updated and forgotten to be re-vendored?

"#]])
            .run();
    }

    #[cargo_test]
    fn missing_dependency_order_check_by_abc() {
        Package::new("the_feat", "0.1.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.0").optional(true))
            .publish();
        quick_ordering!(A, 1);
        quick_ordering!(B, 2);
        quick_ordering!(C, 3);
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_status(101)
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for the requirement `the_feat = "^1.0"`
candidate versions found which didn't match: 0.1.0
location searched: `dummy-registry` index (which is replacing registry `crates-io`)
required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `bar_activator v1.1.0`
    ... which satisfies dependency `bar_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
perhaps a crate was updated and forgotten to be re-vendored?

"#]])
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .with_status(101)
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for the requirement `the_feat = "^1.0"`
candidate versions found which didn't match: 0.1.0
location searched: `dummy-registry` index (which is replacing registry `crates-io`)
required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `feat_activator v1.1.0`
    ... which satisfies dependency `feat_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
perhaps a crate was updated and forgotten to be re-vendored?

"#]])
            .run();
    }

    #[cargo_test]
    fn missing_dependency_order_check_by_bac() {
        Package::new("the_feat", "0.1.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.0").optional(true))
            .publish();
        quick_ordering!(B, 1);
        quick_ordering!(A, 2);
        quick_ordering!(C, 3);
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_status(101)
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for the requirement `the_feat = "^1.0"`
candidate versions found which didn't match: 0.1.0
location searched: `dummy-registry` index (which is replacing registry `crates-io`)
required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `feat_activator v1.1.0`
    ... which satisfies dependency `feat_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
perhaps a crate was updated and forgotten to be re-vendored?

"#]])
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .with_status(101)
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for `bar_wrapper`.
    ... required by package `bar_activator v1.1.0`
    ... which satisfies dependency `bar_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
versions that meet the requirements `^1.1` are: 1.1.2, 1.1.1, 1.1.0

all possible versions conflict with previously selected packages.

  previously selected package `bar_wrapper v1.1.1`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `bar_activator v1.1.0`
    ... which satisfies dependency `bar_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`

failed to select a version for `bar_wrapper` which could resolve this conflict

"#]])
            .run();
    }

    #[cargo_test]
    fn missing_dependency_order_check_by_acb() {
        Package::new("the_feat", "0.1.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.0").optional(true))
            .publish();
        quick_ordering!(A, 1);
        quick_ordering!(C, 2);
        quick_ordering!(B, 3);
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_status(101)
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for the requirement `the_feat = "^1.0"`
candidate versions found which didn't match: 0.1.0
location searched: `dummy-registry` index (which is replacing registry `crates-io`)
required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `bar_activator v1.1.0`
    ... which satisfies dependency `bar_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
perhaps a crate was updated and forgotten to be re-vendored?

"#]])
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .with_status(101)
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for the requirement `the_feat = "^1.0"`
candidate versions found which didn't match: 0.1.0
location searched: `dummy-registry` index (which is replacing registry `crates-io`)
required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `feat_activator v1.1.2`
    ... which satisfies dependency `feat_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
perhaps a crate was updated and forgotten to be re-vendored?

"#]])
            .run();
    }

    #[cargo_test]
    fn missing_dependency_order_check_by_bca() {
        Package::new("the_feat", "0.1.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.0").optional(true))
            .publish();
        quick_ordering!(B, 1);
        quick_ordering!(C, 2);
        quick_ordering!(A, 3);
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_status(101)
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for the requirement `the_feat = "^1.0"`
candidate versions found which didn't match: 0.1.0
location searched: `dummy-registry` index (which is replacing registry `crates-io`)
required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `feat_activator v1.1.0`
    ... which satisfies dependency `feat_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
perhaps a crate was updated and forgotten to be re-vendored?

"#]])
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .with_status(101)
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for the requirement `the_feat = "^1.0"`
candidate versions found which didn't match: 0.1.0
location searched: `dummy-registry` index (which is replacing registry `crates-io`)
required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `feat_activator v1.1.0`
    ... which satisfies dependency `feat_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
perhaps a crate was updated and forgotten to be re-vendored?

"#]])
            .run();
    }
}

mod fallback_bar_activator {
    use super::*;

    #[cargo_test]
    fn fallback_bar_activator_order_check() {
        Package::new("the_feat", "0.1.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.0").optional(true))
            .publish();
        quick_ordering!(A, 1);
        quick_ordering!(B, 1);
        quick_ordering!(C, 1);
        Package::new("bar_activator", "1.0.0")
            .feature_dep("bar_wrapper", "1.0", &[])
            .publish();
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_status(101)
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for the requirement `the_feat = "^1.0"`
candidate versions found which didn't match: 0.1.0
location searched: `dummy-registry` index (which is replacing registry `crates-io`)
required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `feat_activator v1.1.0`
    ... which satisfies dependency `feat_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
perhaps a crate was updated and forgotten to be re-vendored?

"#]])
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(
                str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 3 packages to latest compatible versions
[ADDING] bar_activator v1.0.0 (available: v1.1.0)
[ADDING] bar_wrapper v1.1.0
[ADDING] feat_activator v1.1.0
[DOWNLOADING] crates ...
[DOWNLOADED] feat_activator v1.1.0 (registry `dummy-registry`)
[DOWNLOADED] bar_wrapper v1.1.0 (registry `dummy-registry`)
[DOWNLOADED] bar_activator v1.0.0 (registry `dummy-registry`)
[CHECKING] bar_wrapper v1.1.0
[CHECKING] bar_activator v1.0.0
[CHECKING] feat_activator v1.1.0
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]]
                .unordered(),
            )
            .run();
    }

    #[cargo_test]
    fn fallback_bar_activator_order_check_by_abc() {
        Package::new("the_feat", "0.1.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.0").optional(true))
            .publish();
        quick_ordering!(A, 1);
        quick_ordering!(B, 3);
        quick_ordering!(C, 4);
        Package::new("bar_activator", "1.0.0")
            .feature_dep("bar_wrapper", "1.0", &[])
            .publish();
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_status(101)
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for the requirement `the_feat = "^1.0"`
candidate versions found which didn't match: 0.1.0
location searched: `dummy-registry` index (which is replacing registry `crates-io`)
required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `feat_activator v1.1.0`
    ... which satisfies dependency `feat_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
perhaps a crate was updated and forgotten to be re-vendored?

"#]])
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(
                str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 3 packages to latest compatible versions
[ADDING] bar_activator v1.0.0 (available: v1.1.0)
[ADDING] bar_wrapper v1.1.1 (available: v1.1.3)
[ADDING] feat_activator v1.1.2
[DOWNLOADING] crates ...
[DOWNLOADED] feat_activator v1.1.2 (registry `dummy-registry`)
[DOWNLOADED] bar_wrapper v1.1.1 (registry `dummy-registry`)
[DOWNLOADED] bar_activator v1.0.0 (registry `dummy-registry`)
[CHECKING] bar_wrapper v1.1.1
[CHECKING] bar_activator v1.0.0
[CHECKING] feat_activator v1.1.2
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]]
                .unordered(),
            )
            .run();
    }

    #[cargo_test]
    fn fallback_bar_activator_order_check_by_bac() {
        Package::new("the_feat", "0.1.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.0").optional(true))
            .publish();
        quick_ordering!(B, 1);
        quick_ordering!(A, 1);
        quick_ordering!(C, 3);
        Package::new("bar_activator", "1.0.0")
            .feature_dep("bar_wrapper", "1.0", &[])
            .publish();
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_status(101)
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for the requirement `the_feat = "^1.0"`
candidate versions found which didn't match: 0.1.0
location searched: `dummy-registry` index (which is replacing registry `crates-io`)
required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `feat_activator v1.1.0`
    ... which satisfies dependency `feat_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
perhaps a crate was updated and forgotten to be re-vendored?

"#]])
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(
                str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 3 packages to latest compatible versions
[ADDING] bar_activator v1.0.0 (available: v1.1.0)
[ADDING] bar_wrapper v1.1.2
[ADDING] feat_activator v1.1.0
[DOWNLOADING] crates ...
[DOWNLOADED] feat_activator v1.1.0 (registry `dummy-registry`)
[DOWNLOADED] bar_wrapper v1.1.2 (registry `dummy-registry`)
[DOWNLOADED] bar_activator v1.0.0 (registry `dummy-registry`)
[CHECKING] bar_wrapper v1.1.2
[CHECKING] feat_activator v1.1.0
[CHECKING] bar_activator v1.0.0
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]]
                .unordered(),
            )
            .run();
    }

    #[cargo_test]
    fn fallback_bar_activator_order_check_by_acb() {
        Package::new("the_feat", "0.1.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.0").optional(true))
            .publish();
        quick_ordering!(A, 1);
        quick_ordering!(C, 3);
        quick_ordering!(B, 4);
        Package::new("bar_activator", "1.0.0")
            .feature_dep("bar_wrapper", "1.0", &[])
            .publish();
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_status(101)
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for the requirement `the_feat = "^1.0"`
candidate versions found which didn't match: 0.1.0
location searched: `dummy-registry` index (which is replacing registry `crates-io`)
required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.0"` of package `bar_activator v1.0.0`
    ... which satisfies dependency `bar_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
perhaps a crate was updated and forgotten to be re-vendored?

"#]])
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(
                str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 3 packages to latest compatible versions
[ADDING] bar_activator v1.0.0 (available: v1.1.0)
[ADDING] bar_wrapper v1.1.0 (available: v1.1.2)
[ADDING] feat_activator v1.1.3
[DOWNLOADING] crates ...
[DOWNLOADED] feat_activator v1.1.3 (registry `dummy-registry`)
[DOWNLOADED] bar_wrapper v1.1.0 (registry `dummy-registry`)
[DOWNLOADED] bar_activator v1.0.0 (registry `dummy-registry`)
[CHECKING] bar_wrapper v1.1.0
[CHECKING] feat_activator v1.1.3
[CHECKING] bar_activator v1.0.0
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]]
                .unordered(),
            )
            .run();
    }

    #[cargo_test]
    fn fallback_bar_activator_order_check_by_bca() {
        Package::new("the_feat", "0.1.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.0").optional(true))
            .publish();
        quick_ordering!(B, 1);
        quick_ordering!(C, 2);
        quick_ordering!(A, 2);
        Package::new("bar_activator", "1.0.0")
            .feature_dep("bar_wrapper", "1.0", &[])
            .publish();
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_status(101)
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for the requirement `the_feat = "^1.0"`
candidate versions found which didn't match: 0.1.0
location searched: `dummy-registry` index (which is replacing registry `crates-io`)
required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `feat_activator v1.1.0`
    ... which satisfies dependency `feat_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
perhaps a crate was updated and forgotten to be re-vendored?

"#]])
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(
                str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 3 packages to latest compatible versions
[ADDING] bar_activator v1.0.0 (available: v1.1.1)
[ADDING] bar_wrapper v1.1.0 (available: v1.1.1)
[ADDING] feat_activator v1.1.0
[DOWNLOADING] crates ...
[DOWNLOADED] feat_activator v1.1.0 (registry `dummy-registry`)
[DOWNLOADED] bar_wrapper v1.1.0 (registry `dummy-registry`)
[DOWNLOADED] bar_activator v1.0.0 (registry `dummy-registry`)
[CHECKING] bar_wrapper v1.1.0
[CHECKING] feat_activator v1.1.0
[CHECKING] bar_activator v1.0.0
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]]
                .unordered(),
            )
            .run();
    }
}

mod fallback_feat_activator {
    use super::*;

    #[cargo_test]
    fn fallback_feat_activator_order_check() {
        Package::new("the_feat", "0.1.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.0").optional(true))
            .publish();
        quick_ordering!(A, 1);
        quick_ordering!(B, 1);
        quick_ordering!(C, 1);
        Package::new("feat_activator", "1.0.0")
            .feature_dep("bar_wrapper", "1.1", &[])
            .publish();
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_status(101)
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for the requirement `the_feat = "^1.0"`
candidate versions found which didn't match: 0.1.0
location searched: `dummy-registry` index (which is replacing registry `crates-io`)
required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `bar_activator v1.1.0`
    ... which satisfies dependency `bar_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
perhaps a crate was updated and forgotten to be re-vendored?

"#]])
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .with_status(101)
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for the requirement `the_feat = "^1.0"`
candidate versions found which didn't match: 0.1.0
location searched: `dummy-registry` index (which is replacing registry `crates-io`)
required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `feat_activator v1.1.0`
    ... which satisfies dependency `feat_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
perhaps a crate was updated and forgotten to be re-vendored?

"#]])
            .run();
    }

    #[cargo_test]
    fn fallback_feat_activator_order_check_by_abc() {
        Package::new("the_feat", "0.1.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.0").optional(true))
            .publish();
        quick_ordering!(A, 1);
        quick_ordering!(B, 1);
        quick_ordering!(C, 3);
        Package::new("feat_activator", "1.0.0")
            .feature_dep("bar_wrapper", "1.1", &[])
            .publish();
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_stderr_data(
                str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 4 packages to latest compatible versions
[ADDING] bar_wrapper v1.1.0 (available: v1.1.2)
[ADDING] feat_activator v1.0.0 (available: v1.1.0)
[DOWNLOADING] crates ...
[DOWNLOADED] feat_activator v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar_wrapper v1.1.0 (registry `dummy-registry`)
[DOWNLOADED] bar_activator v1.1.0 (registry `dummy-registry`)
[DOWNLOADED] bar v1.0.0 (registry `dummy-registry`)
[CHECKING] bar v1.0.0
[CHECKING] bar_wrapper v1.1.0
[CHECKING] bar_activator v1.1.0
[CHECKING] feat_activator v1.0.0
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]]
                .unordered(),
            )
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 4 packages to latest compatible versions
[ADDING] bar v1.0.0
[ADDING] bar_activator v1.1.0
[ADDING] bar_wrapper v1.1.0 (available: v1.1.2)
[ADDING] feat_activator v1.0.0 (available: v1.1.0)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
            .run();
    }

    #[cargo_test]
    fn fallback_feat_activator_order_check_by_bac() {
        Package::new("the_feat", "0.1.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.0").optional(true))
            .publish();
        quick_ordering!(B, 1);
        quick_ordering!(A, 3);
        quick_ordering!(C, 4);
        Package::new("feat_activator", "1.0.0")
            .feature_dep("bar_wrapper", "1.1", &[])
            .publish();
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_stderr_data(
                str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 4 packages to latest compatible versions
[ADDING] bar_activator v1.1.0 (available: v1.1.2)
[ADDING] bar_wrapper v1.1.0 (available: v1.1.3)
[ADDING] feat_activator v1.0.0 (available: v1.1.0)
[DOWNLOADING] crates ...
[DOWNLOADED] feat_activator v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar_wrapper v1.1.0 (registry `dummy-registry`)
[DOWNLOADED] bar_activator v1.1.0 (registry `dummy-registry`)
[DOWNLOADED] bar v1.0.0 (registry `dummy-registry`)
[CHECKING] bar v1.0.0
[CHECKING] bar_wrapper v1.1.0
[CHECKING] feat_activator v1.0.0
[CHECKING] bar_activator v1.1.0
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]]
                .unordered(),
            )
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 4 packages to latest compatible versions
[ADDING] bar v1.0.0
[ADDING] bar_activator v1.1.0 (available: v1.1.2)
[ADDING] bar_wrapper v1.1.0 (available: v1.1.3)
[ADDING] feat_activator v1.0.0 (available: v1.1.0)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
            .run();
    }

    #[cargo_test]
    fn fallback_feat_activator_order_check_by_acb() {
        Package::new("the_feat", "0.1.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.0").optional(true))
            .publish();
        quick_ordering!(A, 1);
        quick_ordering!(C, 2);
        quick_ordering!(B, 2);
        Package::new("feat_activator", "1.0.0")
            .feature_dep("bar_wrapper", "1.1", &[])
            .publish();
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_status(101)
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for the requirement `the_feat = "^1.0"`
candidate versions found which didn't match: 0.1.0
location searched: `dummy-registry` index (which is replacing registry `crates-io`)
required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `bar_activator v1.1.0`
    ... which satisfies dependency `bar_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
perhaps a crate was updated and forgotten to be re-vendored?

"#]])
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .with_status(101)
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for the requirement `the_feat = "^1.0"`
candidate versions found which didn't match: 0.1.0
location searched: `dummy-registry` index (which is replacing registry `crates-io`)
required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `feat_activator v1.1.1`
    ... which satisfies dependency `feat_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
perhaps a crate was updated and forgotten to be re-vendored?

"#]])
            .run();
    }

    #[cargo_test]
    fn fallback_feat_activator_order_check_by_bca() {
        Package::new("the_feat", "0.1.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.0").optional(true))
            .publish();
        quick_ordering!(B, 1);
        quick_ordering!(C, 3);
        quick_ordering!(A, 4);
        Package::new("feat_activator", "1.0.0")
            .feature_dep("bar_wrapper", "1.1", &[])
            .publish();
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_stderr_data(
                str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 4 packages to latest compatible versions
[ADDING] bar_activator v1.1.0 (available: v1.1.3)
[ADDING] bar_wrapper v1.1.0 (available: v1.1.2)
[ADDING] feat_activator v1.0.0 (available: v1.1.0)
[DOWNLOADING] crates ...
[DOWNLOADED] feat_activator v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar_wrapper v1.1.0 (registry `dummy-registry`)
[DOWNLOADED] bar_activator v1.1.0 (registry `dummy-registry`)
[DOWNLOADED] bar v1.0.0 (registry `dummy-registry`)
[CHECKING] bar v1.0.0
[CHECKING] bar_wrapper v1.1.0
[CHECKING] bar_activator v1.1.0
[CHECKING] feat_activator v1.0.0
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]]
                .unordered(),
            )
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(
                str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 4 packages to latest compatible versions
[ADDING] bar v1.0.0
[ADDING] bar_activator v1.1.0 (available: v1.1.3)
[ADDING] bar_wrapper v1.1.1 (available: v1.1.2)
[ADDING] feat_activator v1.0.0 (available: v1.1.0)
[DOWNLOADING] crates ...
[DOWNLOADED] bar_wrapper v1.1.1 (registry `dummy-registry`)
[CHECKING] bar_wrapper v1.1.1
[CHECKING] bar_activator v1.1.0
[CHECKING] feat_activator v1.0.0
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]]
                .unordered(),
            )
            .run();
    }
}

mod multiple_the_feat_required {
    use super::*;

    #[cargo_test]
    fn multiple_the_feat_required_order_check() {
        Package::new("the_feat", "1.0.0").publish();
        Package::new("the_feat", "1.1.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.1").optional(true))
            .publish();
        quick_ordering!(A, 1);
        quick_ordering!(B, 1);
        quick_ordering!(C, 1);
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
                the_feat = "=1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_status(101)
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for `the_feat`.
    ... required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `bar_activator v1.1.0`
    ... which satisfies dependency `bar_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
versions that meet the requirements `^1.1` are: 1.1.0

all possible versions conflict with previously selected packages.

  previously selected package `the_feat v1.0.0`
    ... which satisfies dependency `the_feat = "=1.0"` of package `foo v0.1.0 ([ROOT]/foo)`

failed to select a version for `the_feat` which could resolve this conflict

"#]])
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .with_status(101)
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for `the_feat`.
    ... required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `feat_activator v1.1.0`
    ... which satisfies dependency `feat_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
versions that meet the requirements `^1.1` are: 1.1.0

all possible versions conflict with previously selected packages.

  previously selected package `the_feat v1.0.0`
    ... which satisfies dependency `the_feat = "=1.0"` of package `foo v0.1.0 ([ROOT]/foo)`

failed to select a version for `the_feat` which could resolve this conflict

"#]])
            .run();
    }

    #[cargo_test]
    fn multiple_the_feat_required_order_check_by_abc() {
        Package::new("the_feat", "1.0.0").publish();
        Package::new("the_feat", "1.1.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.1").optional(true))
            .publish();
        quick_ordering!(A, 1);
        quick_ordering!(B, 2);
        quick_ordering!(C, 3);
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
                the_feat = "=1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_status(101)
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for `the_feat`.
    ... required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `bar_activator v1.1.0`
    ... which satisfies dependency `bar_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
versions that meet the requirements `^1.1` are: 1.1.0

all possible versions conflict with previously selected packages.

  previously selected package `the_feat v1.0.0`
    ... which satisfies dependency `the_feat = "=1.0"` of package `foo v0.1.0 ([ROOT]/foo)`

failed to select a version for `the_feat` which could resolve this conflict

"#]])
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .with_status(101)
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for `the_feat`.
    ... required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `feat_activator v1.1.0`
    ... which satisfies dependency `feat_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
versions that meet the requirements `^1.1` are: 1.1.0

all possible versions conflict with previously selected packages.

  previously selected package `the_feat v1.0.0`
    ... which satisfies dependency `the_feat = "=1.0"` of package `foo v0.1.0 ([ROOT]/foo)`

failed to select a version for `the_feat` which could resolve this conflict

"#]])
            .run();
    }

    #[cargo_test]
    fn multiple_the_feat_required_order_check_by_bac() {
        Package::new("the_feat", "1.0.0").publish();
        Package::new("the_feat", "1.1.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.1").optional(true))
            .publish();
        quick_ordering!(B, 1);
        quick_ordering!(A, 2);
        quick_ordering!(C, 3);
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
                the_feat = "=1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_status(101)
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for `the_feat`.
    ... required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `feat_activator v1.1.0`
    ... which satisfies dependency `feat_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
versions that meet the requirements `^1.1` are: 1.1.0

all possible versions conflict with previously selected packages.

  previously selected package `the_feat v1.0.0`
    ... which satisfies dependency `the_feat = "=1.0"` of package `foo v0.1.0 ([ROOT]/foo)`

failed to select a version for `the_feat` which could resolve this conflict

"#]])
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .with_status(101)
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for `bar_wrapper`.
    ... required by package `bar_activator v1.1.0`
    ... which satisfies dependency `bar_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
versions that meet the requirements `^1.1` are: 1.1.2, 1.1.1, 1.1.0

all possible versions conflict with previously selected packages.

  previously selected package `foo v0.1.0 ([ROOT]/foo)`

  previously selected package `bar_wrapper v1.1.1`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `bar_activator v1.1.0`
    ... which satisfies dependency `bar_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`

failed to select a version for `bar_wrapper` which could resolve this conflict

"#]])
            .run();
    }

    #[cargo_test]
    fn multiple_the_feat_required_order_check_by_acb() {
        Package::new("the_feat", "1.0.0").publish();
        Package::new("the_feat", "1.1.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.1").optional(true))
            .publish();
        quick_ordering!(A, 1);
        quick_ordering!(C, 2);
        quick_ordering!(B, 3);
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
                the_feat = "=1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_status(101)
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for `the_feat`.
    ... required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `bar_activator v1.1.0`
    ... which satisfies dependency `bar_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
versions that meet the requirements `^1.1` are: 1.1.0

all possible versions conflict with previously selected packages.

  previously selected package `the_feat v1.0.0`
    ... which satisfies dependency `the_feat = "=1.0"` of package `foo v0.1.0 ([ROOT]/foo)`

failed to select a version for `the_feat` which could resolve this conflict

"#]])
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .with_status(101)
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for `the_feat`.
    ... required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `feat_activator v1.1.2`
    ... which satisfies dependency `feat_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
versions that meet the requirements `^1.1` are: 1.1.0

all possible versions conflict with previously selected packages.

  previously selected package `the_feat v1.0.0`
    ... which satisfies dependency `the_feat = "=1.0"` of package `foo v0.1.0 ([ROOT]/foo)`

failed to select a version for `the_feat` which could resolve this conflict

"#]])
            .run();
    }

    #[cargo_test]
    fn multiple_the_feat_required_order_check_by_bca() {
        Package::new("the_feat", "1.0.0").publish();
        Package::new("the_feat", "1.1.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.1").optional(true))
            .publish();
        quick_ordering!(B, 1);
        quick_ordering!(C, 2);
        quick_ordering!(A, 3);
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
                the_feat = "=1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_status(101)
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for `the_feat`.
    ... required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `feat_activator v1.1.0`
    ... which satisfies dependency `feat_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
versions that meet the requirements `^1.1` are: 1.1.0

all possible versions conflict with previously selected packages.

  previously selected package `the_feat v1.0.0`
    ... which satisfies dependency `the_feat = "=1.0"` of package `foo v0.1.0 ([ROOT]/foo)`

failed to select a version for `the_feat` which could resolve this conflict

"#]])
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .with_status(101)
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for `the_feat`.
    ... required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_wrapper v1.1.0`
    ... which satisfies dependency `bar_wrapper = "^1.1"` of package `feat_activator v1.1.0`
    ... which satisfies dependency `feat_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
versions that meet the requirements `^1.1` are: 1.1.0

all possible versions conflict with previously selected packages.

  previously selected package `the_feat v1.0.0`
    ... which satisfies dependency `the_feat = "=1.0"` of package `foo v0.1.0 ([ROOT]/foo)`

failed to select a version for `the_feat` which could resolve this conflict

"#]])
            .run();
    }
}

mod multiple_bar_wrapper_major_version {
    use super::*;

    #[cargo_test]
    fn multiple_bar_wrapper_major_version_order_check() {
        Package::new("the_feat", "1.0.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.0").optional(true))
            .publish();
        Package::new("bar_activator", "1.0.0")
            .feature_dep("bar_wrapper", "^1.0.0", &["bar"])
            .publish();
        Package::new("feat_activator", "1.0.0")
            .feature_dep("bar_wrapper", ">=1.0.0, <=2.0.0", &["feat"])
            .publish();
        Package::new("bar_wrapper", "1.0.0")
            .add_dep(Dependency::new("bar", "1.0").optional(true))
            .feature("feat", &["bar?/the_feat"])
            .publish();
        Package::new("bar_wrapper", "2.0.0")
            .add_dep(Dependency::new("bar", "1.0").optional(true))
            .feature("feat", &["bar?/the_feat"])
            .publish();
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_stderr_data(
                str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 6 packages to latest compatible versions
[DOWNLOADING] crates ...
[DOWNLOADED] the_feat v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] feat_activator v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar_wrapper v2.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar_wrapper v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar_activator v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar v1.0.0 (registry `dummy-registry`)
[CHECKING] bar v1.0.0
[CHECKING] bar_wrapper v2.0.0
[CHECKING] bar_wrapper v1.0.0
[CHECKING] feat_activator v1.0.0
[CHECKING] bar_activator v1.0.0
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]]
                .unordered(),
            )
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 6 packages to latest compatible versions
[ADDING] bar v1.0.0
[ADDING] bar_activator v1.0.0
[ADDING] bar_wrapper v1.0.0
[ADDING] bar_wrapper v2.0.0
[ADDING] feat_activator v1.0.0
[ADDING] the_feat v1.0.0
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
            .run();
    }

    #[cargo_test]
    fn multiple_bar_wrapper_major_version_order_check_by_abc() {
        Package::new("the_feat", "1.0.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.0").optional(true))
            .publish();
        Package::new("bar_activator", "1.0.0")
            .feature_dep("bar_wrapper", "^1.0.0", &["bar"])
            .publish();
        Package::new("feat_activator", "1.0.0")
            .feature_dep("bar_wrapper", ">=1.0.0, <=2.0.0", &["feat"])
            .publish();
        Package::new("feat_activator", "1.0.1")
            .feature_dep("bar_wrapper", ">=1.0.0, <=2.0.0", &["feat"])
            .publish();
        Package::new("bar_wrapper", "1.0.0")
            .add_dep(Dependency::new("bar", "1.0").optional(true))
            .feature("feat", &["bar?/the_feat"])
            .publish();
        Package::new("bar_wrapper", "1.0.1")
            .add_dep(Dependency::new("bar", "1.0").optional(true))
            .feature("feat", &["bar?/the_feat"])
            .publish();
        Package::new("bar_wrapper", "2.0.0")
            .add_dep(Dependency::new("bar", "1.0").optional(true))
            .feature("feat", &["bar?/the_feat"])
            .publish();
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_stderr_data(
                str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 6 packages to latest compatible versions
[DOWNLOADING] crates ...
[DOWNLOADED] the_feat v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] feat_activator v1.0.1 (registry `dummy-registry`)
[DOWNLOADED] bar_wrapper v2.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar_wrapper v1.0.1 (registry `dummy-registry`)
[DOWNLOADED] bar_activator v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar v1.0.0 (registry `dummy-registry`)
[CHECKING] bar v1.0.0
[CHECKING] bar_wrapper v2.0.0
[CHECKING] feat_activator v1.0.1
[CHECKING] bar_wrapper v1.0.1
[CHECKING] bar_activator v1.0.0
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]]
                .unordered(),
            )
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 6 packages to latest compatible versions
[ADDING] bar v1.0.0
[ADDING] bar_activator v1.0.0
[ADDING] bar_wrapper v1.0.1
[ADDING] bar_wrapper v2.0.0
[ADDING] feat_activator v1.0.1
[ADDING] the_feat v1.0.0
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
            .run();
    }

    #[cargo_test]
    fn multiple_bar_wrapper_major_version_order_check_by_bac() {
        Package::new("the_feat", "1.0.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.0").optional(true))
            .publish();
        Package::new("bar_activator", "1.0.0")
            .feature_dep("bar_wrapper", "^1.0.0", &["bar"])
            .publish();
        Package::new("bar_activator", "1.0.1")
            .feature_dep("bar_wrapper", "^1.0.0", &["bar"])
            .publish();
        Package::new("feat_activator", "1.0.0")
            .feature_dep("bar_wrapper", ">=1.0.0, <=2.0.0", &["feat"])
            .publish();
        Package::new("bar_wrapper", "1.0.0")
            .add_dep(Dependency::new("bar", "1.0").optional(true))
            .feature("feat", &["bar?/the_feat"])
            .publish();
        Package::new("bar_wrapper", "1.0.1")
            .add_dep(Dependency::new("bar", "1.0").optional(true))
            .feature("feat", &["bar?/the_feat"])
            .publish();
        Package::new("bar_wrapper", "2.0.0")
            .add_dep(Dependency::new("bar", "1.0").optional(true))
            .feature("feat", &["bar?/the_feat"])
            .publish();
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_stderr_data(
                str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 6 packages to latest compatible versions
[DOWNLOADING] crates ...
[DOWNLOADED] the_feat v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] feat_activator v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar_wrapper v2.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar_wrapper v1.0.1 (registry `dummy-registry`)
[DOWNLOADED] bar_activator v1.0.1 (registry `dummy-registry`)
[DOWNLOADED] bar v1.0.0 (registry `dummy-registry`)
[CHECKING] bar v1.0.0
[CHECKING] bar_wrapper v2.0.0
[CHECKING] bar_wrapper v1.0.1
[CHECKING] feat_activator v1.0.0
[CHECKING] bar_activator v1.0.1
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]]
                .unordered(),
            )
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 6 packages to latest compatible versions
[ADDING] bar v1.0.0
[ADDING] bar_activator v1.0.1
[ADDING] bar_wrapper v1.0.1
[ADDING] bar_wrapper v2.0.0
[ADDING] feat_activator v1.0.0
[ADDING] the_feat v1.0.0
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
            .run();
    }

    #[cargo_test]
    fn multiple_bar_wrapper_major_version_order_check_by_acb() {
        Package::new("the_feat", "1.0.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.0").optional(true))
            .publish();
        Package::new("bar_activator", "1.0.0")
            .feature_dep("bar_wrapper", "^1.0.0", &["bar"])
            .publish();
        Package::new("feat_activator", "1.0.0")
            .feature_dep("bar_wrapper", ">=1.0.0, <=2.0.0", &["feat"])
            .publish();
        Package::new("feat_activator", "1.0.1")
            .feature_dep("bar_wrapper", ">=1.0.0, <=2.0.0", &["feat"])
            .publish();
        Package::new("feat_activator", "1.0.2")
            .feature_dep("bar_wrapper", ">=1.0.0, <=2.0.0", &["feat"])
            .publish();
        Package::new("bar_wrapper", "1.0.0")
            .add_dep(Dependency::new("bar", "1.0").optional(true))
            .feature("feat", &["bar?/the_feat"])
            .publish();
        Package::new("bar_wrapper", "2.0.0")
            .add_dep(Dependency::new("bar", "1.0").optional(true))
            .feature("feat", &["bar?/the_feat"])
            .publish();
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_stderr_data(
                str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 6 packages to latest compatible versions
[DOWNLOADING] crates ...
[DOWNLOADED] the_feat v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] feat_activator v1.0.2 (registry `dummy-registry`)
[DOWNLOADED] bar_wrapper v2.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar_wrapper v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar_activator v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar v1.0.0 (registry `dummy-registry`)
[CHECKING] bar v1.0.0
[CHECKING] bar_wrapper v2.0.0
[CHECKING] bar_wrapper v1.0.0
[CHECKING] feat_activator v1.0.2
[CHECKING] bar_activator v1.0.0
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]]
                .unordered(),
            )
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 6 packages to latest compatible versions
[ADDING] bar v1.0.0
[ADDING] bar_activator v1.0.0
[ADDING] bar_wrapper v1.0.0
[ADDING] bar_wrapper v2.0.0
[ADDING] feat_activator v1.0.2
[ADDING] the_feat v1.0.0
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
            .run();
    }

    #[cargo_test]
    fn multiple_bar_wrapper_major_version_order_check_by_bca() {
        Package::new("the_feat", "1.0.0").publish();
        Package::new("bar", "1.0.0")
            .add_dep(Dependency::new("the_feat", "1.0").optional(true))
            .publish();
        Package::new("bar_activator", "1.0.0")
            .feature_dep("bar_wrapper", "^1.0.0", &["bar"])
            .publish();
        Package::new("bar_activator", "1.0.1")
            .feature_dep("bar_wrapper", "^1.0.0", &["bar"])
            .publish();
        Package::new("bar_activator", "1.0.2")
            .feature_dep("bar_wrapper", "^1.0.0", &["bar"])
            .publish();
        Package::new("feat_activator", "1.0.0")
            .feature_dep("bar_wrapper", ">=1.0.0, <=2.0.0", &["feat"])
            .publish();
        Package::new("bar_wrapper", "1.0.0")
            .add_dep(Dependency::new("bar", "1.0").optional(true))
            .feature("feat", &["bar?/the_feat"])
            .publish();
        Package::new("bar_wrapper", "2.0.0")
            .add_dep(Dependency::new("bar", "1.0").optional(true))
            .feature("feat", &["bar?/the_feat"])
            .publish();
        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                feat_activator = "1.0"
                bar_activator = "1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_stderr_data(
                str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 6 packages to latest compatible versions
[DOWNLOADING] crates ...
[DOWNLOADED] the_feat v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] feat_activator v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar_wrapper v2.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar_wrapper v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar_activator v1.0.2 (registry `dummy-registry`)
[DOWNLOADED] bar v1.0.0 (registry `dummy-registry`)
[CHECKING] bar v1.0.0
[CHECKING] bar_wrapper v2.0.0
[CHECKING] bar_wrapper v1.0.0
[CHECKING] feat_activator v1.0.0
[CHECKING] bar_activator v1.0.2
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]]
                .unordered(),
            )
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 6 packages to latest compatible versions
[ADDING] bar v1.0.0
[ADDING] bar_activator v1.0.2
[ADDING] bar_wrapper v1.0.0
[ADDING] bar_wrapper v2.0.0
[ADDING] feat_activator v1.0.0
[ADDING] the_feat v1.0.0
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
            .run();
    }
}

#[cargo_test]
fn bad_deferred() {
    // A complex chain that requires deferring enabling the feature due to
    // another dependency getting enabled.
    Package::new("the_feat", "0.1.0").publish();
    Package::new("bar", "1.0.0")
        .add_dep(Dependency::new("the_feat", "1.0").optional(true))
        .feature("feat", &["the_feat"])
        .file("src/lib.rs", &require(&["feat"], &[]))
        .publish();
    Package::new("dep", "1.0.0")
        .add_dep(Dependency::new("bar", "1.0").optional(true))
        .feature("feat", &["bar?/feat"])
        .publish();
    Package::new("bar_activator", "1.0.0")
        .feature_dep("bar", "1.0", &[])
        .publish();
    let p = project()
        .file(
            "Cargo.toml",
            r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                dep = { version = "1.0", features = ["feat"] }
                bar_activator = "1.0"
            "#,
        )
        .file("src/lib.rs", "")
        .build();

    p.cargo("check")
        .with_status(101)
        .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for the requirement `the_feat = "^1.0"`
candidate versions found which didn't match: 0.1.0
location searched: `dummy-registry` index (which is replacing registry `crates-io`)
required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `bar_activator v1.0.0`
    ... which satisfies dependency `bar_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
perhaps a crate was updated and forgotten to be re-vendored?

"#]])
        .run();

    // Update to new lockfile version
    p.change_file("Cargo.lock", "version = 5");

    p.cargo("check -Znext-lockfile-bump")
        .with_status(101)
        .masquerade_as_nightly_cargo(&["weak_dep_check"])
        .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for the requirement `the_feat = "^1.0"`
candidate versions found which didn't match: 0.1.0
location searched: `dummy-registry` index (which is replacing registry `crates-io`)
required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `dep v1.0.0`
    ... which satisfies dependency `dep = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
perhaps a crate was updated and forgotten to be re-vendored?

"#]])
        .run();
}

#[cargo_test]
fn try_defer_to_old_version_bar_activator() {
    // A complex chain that requires deferring enabling the feature due to
    // another dependency getting enabled.
    Package::new("the_feat", "0.1.0").publish();
    Package::new("bar", "1.0.0")
        .add_dep(Dependency::new("the_feat", "1.0").optional(true))
        .feature("feat", &["the_feat"])
        .publish();
    Package::new("dep", "1.0.0")
        .add_dep(Dependency::new("bar", "1.0").optional(true))
        .feature("feat", &["bar?/feat"])
        .publish();
    Package::new("bar_activator", "1.1.0")
        .feature_dep("dep", "1.0", &["bar"])
        .publish();
    Package::new("bar_activator", "1.0.0")
        .feature_dep("dep", "1.0", &[])
        .publish();
    let p = project()
        .file(
            "Cargo.toml",
            r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                dep = { version = "1.0", features = ["feat"] }
                bar_activator = "1.0"
            "#,
        )
        .file("src/lib.rs", "")
        .build();

    p.cargo("check")
        .with_status(101)
        .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for the requirement `the_feat = "^1.0"`
candidate versions found which didn't match: 0.1.0
location searched: `dummy-registry` index (which is replacing registry `crates-io`)
required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `dep v1.0.0`
    ... which satisfies dependency `dep = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
perhaps a crate was updated and forgotten to be re-vendored?

"#]])
        .run();

    // Update to new lockfile version
    p.change_file("Cargo.lock", "version = 5");

    p.cargo("check -Znext-lockfile-bump")
        .masquerade_as_nightly_cargo(&["weak_dep_check"])
        .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 2 packages to latest compatible versions
[ADDING] bar_activator v1.0.0 (available: v1.1.0)
[ADDING] dep v1.0.0
[DOWNLOADING] crates ...
[DOWNLOADED] dep v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar_activator v1.0.0 (registry `dummy-registry`)
[CHECKING] dep v1.0.0
[CHECKING] bar_activator v1.0.0
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
        .run();
}

#[cargo_test]
fn try_defer_to_old_version_dep() {
    // A complex chain that requires deferring enabling the feature due to
    // another dependency getting enabled.
    Package::new("the_feat", "0.1.0").publish();
    Package::new("bar", "1.0.0")
        .add_dep(Dependency::new("the_feat", "1.0").optional(true))
        .feature("feat", &["the_feat"])
        .publish();
    Package::new("dep", "1.1.0")
        .add_dep(Dependency::new("bar", "1.0").optional(true))
        .feature("feat", &["bar?/feat"])
        .publish();
    Package::new("dep", "1.0.0")
        .add_dep(Dependency::new("bar", "1.0").optional(true))
        .feature("feat", &[])
        .publish();
    Package::new("bar_activator", "1.0.0")
        .feature_dep("dep", "1.0", &[])
        .publish();
    let p = project()
        .file(
            "Cargo.toml",
            r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                dep = { version = "1.0", features = ["feat"] }
                bar_activator = "1.0"
            "#,
        )
        .file("src/lib.rs", "")
        .build();

    p.cargo("check")
        .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 2 packages to latest compatible versions
[ADDING] dep v1.0.0 (available: v1.1.0)
[DOWNLOADING] crates ...
[DOWNLOADED] dep v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] bar_activator v1.0.0 (registry `dummy-registry`)
[CHECKING] dep v1.0.0
[CHECKING] bar_activator v1.0.0
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
        .run();

    p.cargo("update --precise 1.1.0 --package dep")
        .with_status(101)
        .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for the requirement `the_feat = "^1.0"`
candidate versions found which didn't match: 0.1.0
location searched: `dummy-registry` index (which is replacing registry `crates-io`)
required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `dep v1.1.0`
    ... which satisfies dependency `dep = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
perhaps a crate was updated and forgotten to be re-vendored?

"#]])
        .run();

    // Update to new lockfile version
    p.change_file("Cargo.lock", "version = 5");

    p.cargo("check -Znext-lockfile-bump")
        .masquerade_as_nightly_cargo(&["weak_dep_check"])
        .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 2 packages to latest compatible versions
[ADDING] bar_activator v1.0.0
[ADDING] dep v1.1.0
[DOWNLOADING] crates ...
[DOWNLOADED] dep v1.1.0 (registry `dummy-registry`)
[CHECKING] dep v1.1.0
[CHECKING] bar_activator v1.0.0
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]])
        .run();
}

#[cargo_test]
fn defer_to_incompatible_the_feat() {
    // A complex chain that requires deferring enabling the feature due to
    // another dependency getting enabled.
    Package::new("the_feat", "1.0.0").publish();
    Package::new("the_feat", "1.5.0").publish();
    Package::new("bar", "1.0.0")
        .add_dep(Dependency::new("the_feat", "1.5").optional(true))
        .feature("feat", &["the_feat"])
        .file("src/lib.rs", &require(&["feat"], &[]))
        .publish();
    Package::new("dep", "1.0.0")
        .add_dep(Dependency::new("bar", "1.0").optional(true))
        .feature("feat", &["bar?/feat"])
        .publish();
    Package::new("bar_activator", "1.0.0")
        .feature_dep("dep", "1.0", &["bar"])
        .publish();
    let p = project()
        .file(
            "Cargo.toml",
            r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                dep = { version = "1.0", features = ["feat"] }
                bar_activator = "1.0"
                the_feat = "=1.0"
            "#,
        )
        .file("src/lib.rs", "")
        .build();

    p.cargo("check")
        .with_status(101)
        .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for `the_feat`.
    ... required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `dep v1.0.0`
    ... which satisfies dependency `dep = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
versions that meet the requirements `^1.5` are: 1.5.0

all possible versions conflict with previously selected packages.

  previously selected package `the_feat v1.0.0`
    ... which satisfies dependency `the_feat = "=1.0"` of package `foo v0.1.0 ([ROOT]/foo)`

failed to select a version for `the_feat` which could resolve this conflict

"#]])
        .run();

    // Update to new lockfile version
    p.change_file("Cargo.lock", "version = 5");

    p.cargo("check -Znext-lockfile-bump")
        .with_status(101)
        .masquerade_as_nightly_cargo(&["weak_dep_check"])
        .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for `the_feat`.
    ... required by package `bar v1.0.0`
    ... which satisfies dependency `bar = "^1.0"` of package `dep v1.0.0`
    ... which satisfies dependency `dep = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
versions that meet the requirements `^1.5` are: 1.5.0

all possible versions conflict with previously selected packages.

  previously selected package `the_feat v1.0.0`
    ... which satisfies dependency `the_feat = "=1.0"` of package `foo v0.1.0 ([ROOT]/foo)`

failed to select a version for `the_feat` which could resolve this conflict

"#]])
        .run();
}

#[cargo_test]
fn defer_to_bad_feat() {
    // A complex chain that requires deferring enabling the feature due to
    // another dependency getting enabled.
    Package::new("bar", "1.0.0").feature("feat", &[]).publish();
    Package::new("dep", "1.0.0")
        .add_dep(Dependency::new("bar", "1.0").optional(true))
        .feature("feat", &["bar?/bad"])
        .publish();
    Package::new("bar_activator", "1.0.0")
        .dep("bar", "1.0")
        .publish();
    let p = project()
        .file(
            "Cargo.toml",
            r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                dep = { version = "1.0", features = ["feat"] }
                bar_activator = "1.0"
            "#,
        )
        .file("src/lib.rs", "")
        .build();

    p.cargo("check")
        .with_status(101)
        .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for `bar`.
    ... required by package `dep v1.0.0`
    ... which satisfies dependency `dep = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
versions that meet the requirements `^1.0` are: 1.0.0

package `dep` depends on `bar` with feature `bad` but `bar` does not have that feature.
 package `bar` does have feature `feat`


failed to select a version for `bar` which could resolve this conflict

"#]])
        .run();

    // Update to new lockfile version
    p.change_file("Cargo.lock", "version = 5");

    p.cargo("check -Znext-lockfile-bump")
        .with_status(101)
        .masquerade_as_nightly_cargo(&["weak_dep_check"])
        .with_stderr_data(str![[r#"
[UPDATING] `dummy-registry` index
[ERROR] failed to select a version for `bar`.
    ... required by package `bar_activator v1.0.0`
    ... which satisfies dependency `bar_activator = "^1.0"` of package `foo v0.1.0 ([ROOT]/foo)`
versions that meet the requirements `^1.0` are: 1.0.0

package `dep` depends on `bar` with feature `bad` but `bar` does not have that feature.
 package `bar` does have feature `feat`


failed to select a version for `bar` which could resolve this conflict

"#]])
        .run();
}
mod double_dep_defer_to_one {
    use super::*;

    #[cargo_test]
    fn double_dep_defer_to_one_order_check() {
        Package::new("feat1", "1.0.0").publish();
        Package::new("feat2", "1.0.0").publish();
        Package::new("feat_container", "1.0.0")
            .add_dep(Dependency::new("feat1", "1.0").optional(true))
            .add_dep(Dependency::new("feat2", "1.0").optional(true))
            .publish();
        Package::new("feat1_activator", "1.0.0")
            .add_dep(Dependency::new("feat_container", "1.0").optional(true))
            .feature("default", &["feat_container?/feat1"])
            .publish();
        Package::new("feat2_activator", "1.0.0")
            .add_dep(Dependency::new("feat_container", "1.0").optional(true))
            .feature("default", &["feat_container?/feat2"])
            .publish();
        Package::new("container_activator", "1.0.0")
            .dep("feat_container", "1.0")
            .publish();

        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                container_activator = "1.0"
                feat1_activator = "1.0"
                feat2_activator = "1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_stderr_data(
                str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 6 packages to latest compatible versions
[DOWNLOADING] crates ...
[DOWNLOADED] feat_container v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] feat2_activator v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] feat2 v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] feat1_activator v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] feat1 v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] container_activator v1.0.0 (registry `dummy-registry`)
[CHECKING] feat_container v1.0.0
[CHECKING] feat1_activator v1.0.0
[CHECKING] feat2_activator v1.0.0
[CHECKING] container_activator v1.0.0
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]]
                .unordered(),
            )
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(
                str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 6 packages to latest compatible versions
[ADDING] container_activator v1.0.0
[ADDING] feat1 v1.0.0
[ADDING] feat1_activator v1.0.0
[ADDING] feat2 v1.0.0
[ADDING] feat2_activator v1.0.0
[ADDING] feat_container v1.0.0
[CHECKING] feat1 v1.0.0
[CHECKING] feat2 v1.0.0
[CHECKING] feat_container v1.0.0
[CHECKING] feat1_activator v1.0.0
[CHECKING] feat2_activator v1.0.0
[CHECKING] container_activator v1.0.0
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]]
                .unordered(),
            )
            .run();
    }

    #[cargo_test]
    fn double_dep_defer_to_one_order_check_f1cf2() {
        Package::new("feat1", "1.0.0").publish();
        Package::new("feat2", "1.0.0").publish();
        Package::new("feat_container", "1.0.0")
            .add_dep(Dependency::new("feat1", "1.0").optional(true))
            .add_dep(Dependency::new("feat2", "1.0").optional(true))
            .publish();
        Package::new("feat1_activator", "1.0.0")
            .add_dep(Dependency::new("feat_container", "1.0").optional(true))
            .feature("default", &["feat_container?/feat1"])
            .publish();
        Package::new("container_activator", "1.0.0")
            .dep("feat_container", "1.0")
            .publish();
        Package::new("container_activator", "1.0.1")
            .dep("feat_container", "1.0")
            .publish();
        Package::new("feat2_activator", "1.0.0")
            .add_dep(Dependency::new("feat_container", "1.0").optional(true))
            .feature("default", &["feat_container?/feat2"])
            .publish();
        Package::new("feat2_activator", "1.0.1")
            .add_dep(Dependency::new("feat_container", "1.0").optional(true))
            .feature("default", &["feat_container?/feat2"])
            .publish();
        Package::new("feat2_activator", "1.0.2")
            .add_dep(Dependency::new("feat_container", "1.0").optional(true))
            .feature("default", &["feat_container?/feat2"])
            .publish();

        let p = project()
            .file(
                "Cargo.toml",
                r#"
                [package]
                name = "foo"
                version = "0.1.0"
                edition = "2015"

                [dependencies]
                container_activator = "1.0"
                feat1_activator = "1.0"
                feat2_activator = "1.0"
            "#,
            )
            .file("src/lib.rs", "")
            .build();

        p.cargo("check")
            .with_stderr_data(
                str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 6 packages to latest compatible versions
[DOWNLOADING] crates ...
[DOWNLOADED] feat_container v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] feat2_activator v1.0.2 (registry `dummy-registry`)
[DOWNLOADED] feat2 v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] feat1_activator v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] feat1 v1.0.0 (registry `dummy-registry`)
[DOWNLOADED] container_activator v1.0.1 (registry `dummy-registry`)
[CHECKING] feat_container v1.0.0
[CHECKING] feat1_activator v1.0.0
[CHECKING] feat2_activator v1.0.2
[CHECKING] container_activator v1.0.1
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]]
                .unordered(),
            )
            .run();

        // Update to new lockfile version
        p.change_file("Cargo.lock", "version = 5");

        p.cargo("check -Znext-lockfile-bump")
            .masquerade_as_nightly_cargo(&["weak_dep_check"])
            .with_stderr_data(
                str![[r#"
[UPDATING] `dummy-registry` index
[LOCKING] 6 packages to latest compatible versions
[ADDING] container_activator v1.0.1
[ADDING] feat1 v1.0.0
[ADDING] feat1_activator v1.0.0
[ADDING] feat2 v1.0.0
[ADDING] feat2_activator v1.0.2
[ADDING] feat_container v1.0.0
[CHECKING] feat1 v1.0.0
[CHECKING] feat2 v1.0.0
[CHECKING] feat_container v1.0.0
[CHECKING] container_activator v1.0.1
[CHECKING] feat1_activator v1.0.0
[CHECKING] feat2_activator v1.0.2
[CHECKING] foo v0.1.0 ([ROOT]/foo)
[FINISHED] `dev` profile [unoptimized + debuginfo] target(s) in [ELAPSED]s

"#]]
                .unordered(),
            )
            .run();
    }
}
