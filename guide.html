<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    
    <!-- Always force latest IE rendering engine or request Chrome Frame -->
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    
    <!-- Use title if it's in the page YAML frontmatter -->
    <title>Guide</title>
    
    <link href="stylesheets/all.css" rel="stylesheet" type="text/css" />
    <script src="javascripts/all.js" type="text/javascript"></script>
  </head>
  
  <body class="guide">
    <a href="https://github.com/rust-lang/cargo"><img class="fork-me" alt="" width="149" height="149" src="images/forkme.png" /></a>
    <a href="./"><img class="logo" alt="" width="306" height="275" src="images/Cargo-Logo-Small.png" /></a>

    <main>
      <p>Cargo downloads your <a href="http://rust-lang.org">Rust</a> project's dependencies and builds your project</p>

      <p>Welcome to the Cargo guide. This guide will give you all that you need to know
about how to use Cargo to develop Rust projects.</p>

<h1>Why Cargo exists</h1>

<p>Cargo is a tool that allows Rust projects to declare their various
dependencies, and ensure that you&rsquo;ll always get a repeatable build.</p>

<p>To accomplish this goal, Cargo does four things:</p>

<ul>
<li>Introduces two metadata files with various bits of project information.</li>
<li>Fetches and builds your project&rsquo;s dependencies.</li>
<li>Invokes <code>rustc</code> or another build tool with the correct parameters to build your project.</li>
<li>Introduces conventions, making working with Rust projects easier.</li>
</ul>

<h1>Converting to Cargo</h1>

<p>You can convert an existing Rust project to use Cargo. You&rsquo;ll have to create a
<code>Cargo.toml</code> file with all of your dependencies, and move your source files and
test files into the places where Cargo expects them to be. See the <a href="manifest.html">manifest
description</a> and the &ldquo;Cargo Conventions&rdquo; section below for more
details.</p>

<h1>Creating A New Project</h1>

<p>To start a new project with Cargo, use <code>cargo new</code>:</p>
<pre><code class="highlight shell"><span class="gp">$ </span>cargo new hello_world --bin
</code></pre>

<p>We&rsquo;re passing <code>--bin</code> because we&rsquo;re making a binary program: if we
were making a library, we&rsquo;d leave it off.</p>

<p>Let&rsquo;s check out what Cargo has generated for us:</p>
<pre><code class="highlight shell"><span class="gp">$ </span><span class="nb">cd </span>hello_world
<span class="gp">$ </span>tree .
.
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files
</code></pre>

<p>This is all we need to get started. First, let&rsquo;s check out <code>Cargo.toml</code>:</p>
<pre><code class="highlight toml"><span class="nn">[package]</span>

<span class="py">name</span> <span class="p">=</span> <span class="s">"hello_world"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.0.1"</span>
<span class="py">authors</span> <span class="p">=</span> <span class="p">[</span><span class="s">"Yehuda Katz &lt;wycats@example.com&gt;"</span><span class="p">]</span>
</code></pre>

<p>This is called a <strong>manifest</strong>, and it contains all of the metadata that Cargo
needs to compile your project. </p>

<p>Here&rsquo;s what&rsquo;s in <code>src/main.rs</code>:</p>
<pre><code class="highlight rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello world!"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>

<p>Cargo generated a &lsquo;hello world&rsquo; for us. Let&rsquo;s compile it:</p>

<pre><code class="highlight"><span class="gp">$</span> cargo build
<span style="font-weight: bold"
class="s1">   Compiling</span> hello-world v0.1.0</code></pre>

<p>And then run it:</p>
<pre><code class="highlight shell"><span class="gp">$ </span>./target/hello-world
Hello world!
</code></pre>

<p>We can also use <code>cargo run</code> to compile and then run it, all in one step:</p>

<pre><code class="highlight"><span class="gp">$</span> cargo run
<span style="font-weight: bold"
class="s1">   Fresh</span> hello-world v0.1.0
<span style="font-weight: bold"
class="s1">   Running</span> `target/hello_world`
Hello world!</code></pre>

<p>You&rsquo;ll now notice a new file, <code>Cargo.lock</code>. It contains information about our
dependencies. Since we don&rsquo;t have any yet, it&rsquo;s not very interesting.</p>

<h1>Working on an existing Cargo project</h1>

<p>If you download an existing project that uses Cargo, it&rsquo;s really easy
to get going.</p>

<p>First, get the project from somewhere. In this example, we&rsquo;ll use <code>color-rs</code>:</p>
<pre><code class="highlight shell"><span class="gp">$ </span>git clone https://github.com/bjz/color-rs.git
<span class="gp">$ </span><span class="nb">cd </span>color-rs
</code></pre>

<p>To build, just use <code>cargo build</code>:</p>

<pre><code class="highlight"><span class="gp">$</span> cargo build
<span style="font-weight: bold" class="s1">   Compiling</span> color v1.0.0 (https://github.com/bjz/color-rs.git)</code></pre>

<p>This will fetch all of the dependencies and then build them, along with the
project.</p>

<h1>Adding Dependencies</h1>

<p>To depend on a library, add it to your <code>Cargo.toml</code>.</p>
<pre><code class="highlight toml"><span class="nn">[package]</span>

<span class="py">name</span> <span class="p">=</span> <span class="s">"hello-world"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">authors</span> <span class="p">=</span> <span class="p">[</span><span class="s">"Yehuda Katz &lt;wycats@example.com&gt;"</span><span class="p">]</span>

<span class="nn">[dependencies.color]</span>

<span class="py">git</span> <span class="p">=</span> <span class="s">"https://github.com/bjz/color-rs.git"</span>
</code></pre>

<p>You added the <code>color</code> library, which provides simple conversions
between different color types.</p>

<p>Now, you can pull in that library using <code>extern crate</code> in
<code>main.rs</code>.</p>
<pre><code class="highlight rust"><span class="k">extern</span> <span class="n">crate</span> <span class="n">color</span><span class="p">;</span>

<span class="k">use</span> <span class="nn">color</span><span class="p">::{</span><span class="n">RGB</span><span class="p">,</span> <span class="n">ToHSV</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Converting RGB to HSV!"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">red</span> <span class="o">=</span> <span class="nn">RGB</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">255u8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"HSV: {}"</span><span class="p">,</span> <span class="n">red</span><span class="py">.to_hsv</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">());</span>
<span class="p">}</span>
</code></pre>

<p>Let&rsquo;s tell Cargo to fetch this new dependency and update the <code>Cargo.lock</code>:</p>

<pre><code class="highlight"><span class="gp">$</span> cargo update color
<span style="font-weight: bold" class="s1">    Updating</span> git repository `https://github.com/bjz/color-rs.git`</code></pre>

<p>Compile it:</p>

<pre><code class="highlight"><span class="gp">$</span> cargo run
<span style="font-weight: bold" class="s1">   Compiling</span> color v1.0.0 (https://github.com/bjz/color-rs.git#bf739419)
<span style="font-weight: bold" class="s1">   Compiling</span> hello-world v0.1.0
$ ./target/hello-world
Converting RGB to HSV!
HSV: HSV { h: 0, s: 1, v: 1 }</code></pre>

<p>We just specified a <code>git</code> repository for our dependency, but our <code>Cargo.lock</code>
contains the exact information about which revision we used:</p>
<pre><code class="highlight toml"><span class="nn">[root]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"hello_world"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.0.1"</span>
<span class="py">dependencies</span> <span class="p">=</span> <span class="p">[</span>
 <span class="s">"color 0.0.1 (git+https://github.com/bjz/color-rs.git#bf739419e2d31050615c1ba1a395b474269a4)"</span><span class="p">,</span>
<span class="p">]</span>

<span class="nn">[[package]]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"color"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.0.1"</span>
<span class="py">source</span> <span class="p">=</span> <span class="s">"git+https://github.com/bjz/color-rs.git#bf739419e2d31050615c1ba1a395b474269a4"</span>
</code></pre>

<p>Now, if <code>color-rs</code> gets updated, we will still build with the same revision, until
we choose to <code>cargo update</code> again.</p>

<h1>Cargo Conventions</h1>

<p>Cargo uses conventions to make it easy to dive into a new Cargo project. Here
are the conventions that Cargo uses:</p>

<ul>
<li><code>Cargo.toml</code> and <code>Cargo.lock</code> are stored in the root of your project.</li>
<li>Source code goes in the <code>src</code> directory.</li>
<li>External tests go in the <code>tests</code> directory.</li>
<li>The default executable file is <code>src/main.rs</code>.</li>
<li>Other executables can be placed in <code>src/bin/*.rs</code>.</li>
<li>The default library file is <code>src/lib.rs</code>.</li>
</ul>

<h1>Cargo.toml vs Cargo.lock</h1>

<p><code>Cargo.toml</code> and <code>Cargo.lock</code> serve two different purposes. Before we talk
about them, here&rsquo;s a summary:</p>

<ul>
<li><code>Cargo.toml</code> is about describing your dependencies in a broad sense, and is written by you.</li>
<li><code>Cargo.lock</code> contains exact information about your dependencies, and is maintained by Cargo.</li>
<li>If you&rsquo;re building a library, put <code>Cargo.lock</code> in your <code>.gitignore</code>.</li>
<li>If you&rsquo;re building an executable, check <code>Cargo.lock</code> into <code>git</code>.</li>
</ul>

<p>Let&rsquo;s dig in a little bit more.</p>

<p><code>Cargo.toml</code> is a <strong>manifest</strong> file. In the manifest, we can specify a bunch of
different metadata about our project. For example, we can say that we depend
on another project:</p>
<pre><code class="highlight toml"><span class="nn">[package]</span>

<span class="py">name</span> <span class="p">=</span> <span class="s">"hello-world"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">authors</span> <span class="p">=</span> <span class="p">[</span><span class="s">"Yehuda Katz &lt;wycats@example.com&gt;"</span><span class="p">]</span>

<span class="nn">[dependencies.color]</span>

<span class="py">git</span> <span class="p">=</span> <span class="s">"https://github.com/bjz/color-rs.git"</span>
</code></pre>

<p>This project has a single dependency, on the <code>color</code> library. We&rsquo;ve stated in
this case that we&rsquo;re relying on a particular Git repository that lives on
GitHub. Since we haven&rsquo;t specified any other information, Cargo assumes that
we intend to use the latest commit on the <code>master</code> branch to build our project.</p>

<p>Sound good? Well, there&rsquo;s one problem: If you build this project today, and
then you send a copy to me, and I build this project tomorrow, something bad
could happen. <code>bjz</code> could update <code>color-rs</code> in the meantime, and my build would
include this commit, while yours would not. Therefore, we would get different
builds. This would be bad, because we want reproducible builds.</p>

<p>We could fix this problem by putting a <code>rev</code> line in our <code>Cargo.toml</code>:</p>
<pre><code class="highlight toml"><span class="nn">[dependencies.color]</span>

<span class="py">git</span> <span class="p">=</span> <span class="s">"https://github.com/bjz/color-rs.git"</span>
<span class="py">rev</span> <span class="p">=</span> <span class="s">"bf739419e2d31050615c1ba1a395b474269a4"</span>
</code></pre>

<p>Now, our builds will be the same. But, there&rsquo;s a big drawback: now we have to
manually think about SHA-1s every time we want to update our library. This is
both tedius and error prone.</p>

<p>Enter the <code>Cargo.lock</code>. Because of its existence, we don&rsquo;t need to manually
keep track of the exact revisions: Cargo will do it for us. When we have a
manifest like this:</p>
<pre><code class="highlight toml"><span class="nn">[package]</span>

<span class="py">name</span> <span class="p">=</span> <span class="s">"hello-world"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">authors</span> <span class="p">=</span> <span class="p">[</span><span class="s">"Yehuda Katz &lt;wycats@example.com&gt;"</span><span class="p">]</span>

<span class="nn">[dependencies.color]</span>

<span class="py">git</span> <span class="p">=</span> <span class="s">"https://github.com/bjz/color-rs.git"</span>
</code></pre>

<p>Cargo will take the latest commit, and write that information out into our
<code>Cargo.lock</code> when we build for the first time. That file will look like this:</p>
<pre><code class="highlight toml"><span class="nn">[root]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"hello_world"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.0.1"</span>
<span class="py">dependencies</span> <span class="p">=</span> <span class="p">[</span>
 <span class="s">"color 0.0.1 (git+https://github.com/bjz/color-rs.git#bf739419e2d31050615c1ba1a395b47426)"</span><span class="p">,</span>
<span class="p">]</span>

<span class="nn">[[package]]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"color"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.0.1"</span>
<span class="py">source</span> <span class="p">=</span> <span class="s">"git+https://github.com/bjz/color-rs.git#bf739419e2d31050615c1ba1a395b47426"</span>
</code></pre>

<p>You can see that there&rsquo;s a lot more information here, including the exact
revision we used to build. Now, when you give your project to someone else,
they&rsquo;ll use the exact same SHA, even though we didn&rsquo;t specify it in our
<code>Cargo.toml</code>.</p>

<p>When we&rsquo;re ready to opt in to a new version of the library, Cargo can
re-calculate the dependencies, and update things for us:</p>
<pre><code class="highlight shell"><span class="gp">$ </span>cargo update       <span class="c"># updates all dependencies</span>
<span class="gp">$ </span>cargo update color <span class="c"># updtes just 'color'</span>
</code></pre>

<p>This will write out a new <code>Cargo.lock</code> with the new version information.</p>

<h1>Overriding Dependencies</h1>

<p>Sometimes, you may want to override one of Cargo&rsquo;s dependencies. For example,
let&rsquo;s say you&rsquo;re working on a project, <code>conduit-static</code>, which depends on
the package <code>conduit</code>. You find a bug in <code>conduit</code>, and you want to write a
patch. Here&rsquo;s what <code>conduit-static</code>&rsquo;s <code>Cargo.toml</code> looks like:</p>
<pre><code class="highlight toml"><span class="nn">[package]</span>

<span class="py">name</span> <span class="p">=</span> <span class="s">"conduit-static"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">authors</span> <span class="p">=</span> <span class="p">[</span><span class="s">"Yehuda Katz &lt;wycats@example.com&gt;"</span><span class="p">]</span>

<span class="nn">[dependencies.conduit]</span>

<span class="py">git</span> <span class="p">=</span> <span class="s">"https://github.com/conduit-rust/conduit.git"</span>
</code></pre>

<p>You check out a local copy of <code>conduit</code>, let&rsquo;s say in your <code>~/src</code> directory:</p>
<pre><code class="highlight shell"><span class="gp">$ </span><span class="nb">cd</span> ~/src
<span class="gp">$ </span>git clone https://github.com/conduit-rust/conduit.git
</code></pre>

<p>You&rsquo;d like to have <code>conduit-static</code> use your local version of <code>conduit</code>,
rather than the one on GitHub, while you fix the bug.</p>

<p>Cargo solves this problem by allowing you to have a local configuration
that specifies an <strong>override</strong>. If Cargo finds this configuration when
building your package, it will use the override on your local machine
instead of the source specified in your <code>Cargo.toml</code>.</p>

<p>Cargo looks for a directory named <code>.cargo</code> up the directory hierarchy of
your project. If your project is in <code>/Users/wycats/src/conduit-static</code>,
it will search for a <code>.cargo</code> in:</p>

<ul>
<li><code>/Users/wycats/src/conduit-static</code></li>
<li><code>/Users/wycats/src</code></li>
<li><code>/Users/wycats</code></li>
<li><code>/Users</code></li>
<li><code>/</code></li>
</ul>

<p>This allows you to specify your overrides in a parent directory that
includes commonly used packages that you work on locally, and share them
with all projects.</p>

<p>To specify overrides, create a <code>.cargo/config</code> file in some ancestor of
your project&rsquo;s directory (common places to put it is in the root of
your code directory or in your home directory).</p>

<p>Inside that file, put this:</p>
<pre><code class="highlight plaintext">paths = ["/home/you/src/conduit"]
</code></pre>

<p>This array should be filled with directories that contain a <code>Cargo.toml</code>. In
this instance, we&rsquo;re just adding <code>conduit</code>, so it will be the only one that&rsquo;s
overridden.</p>

<h1>Tests</h1>

<p>Cargo can run your tests with the <code>cargo test</code> command. Cargo runs tests in two
places: in each of your <code>src</code> files, and any tests in <code>tests/</code>. Tests
in your <code>src</code> files should be unit tests, and tests in <code>tests/</code> should be
integration-style tests. As such, you&rsquo;ll need to import your crates into
the files in <code>tests</code>.</p>

<p>To run your tests, just run <code>cargo test</code>:</p>

<pre><code class="highlight"><span class="gp">$</span> cargo test
<span style="font-weight: bold"
class="s1">   Compiling</span> hello-world v0.1.0
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>

<p>Of course, if your project has tests, you&rsquo;ll see more output, with the
correct number of tests.</p>

<h2>Travis-CI</h2>

<p>To test your project on Travis-CI, here is a sample <code>.travis.yml</code> file:</p>
<pre><code class="highlight plaintext">install:
  - curl http://www.rust-lang.org/rustup.sh | sudo sh -
script:
  - cargo build --verbose
  - cargo test --verbose
</code></pre>


      <footer>
        <a href="guide.html">Guide</a> |
        <a href="faq.html">Frequently Asked Questions</a> |
        <a href="manifest.html">Manifest Format</a> |
        <a href="native-build.html">Building Non-Rust Code</a>
      </footer>
    </main>

  </body>
</html>
