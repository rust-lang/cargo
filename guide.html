<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Guide</title>

    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css">
<link rel="stylesheet" type="text/css" href="stylesheets/all.css">
<link rel="stylesheet" type="text/css" href="stylesheets/prism.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>

<a href='https://github.com/rust-lang/cargo' class='fork-me'>
  <img src='images/forkme.png'/>
</a>

<div id="header">
    <a href='https://crates.io' class='logo'>
        <img id="logo" height=100 width=100 src='images/Cargo-Logo-Small.png'/>
    </a>
    <a href="index.html">
        <h1>CARGO</h1>
    </a>

    <div class="search">
        <form action="https://crates.io/search"
              method="GET">
            <input name="q" class="search" placeholder="Search crates" type="text"/>
        </form>
    </div>

    <div class="nav">
        <a href='https://crates.io/crates'>Browse All Crates</a>

        <span class='sep'>|</span>

        <div class="dropdown-container">
            <button class="dropdown">
                Documentation
                <span class="arrow"></span>
            </button>
            <ul id="current-user-links" class="dropdown" data-bindattr-503="503">
                <li><a href='index.html'>Getting Started</a></li>
                <li><a href='guide.html'>Guide</a></li>
                <li><a href='crates-io.html'>Using crates.io</a></li>
                <li><a href='faq.html'>FAQ</a></li>
                <li><a href='manifest.html'>Manifest Format</a></li>
                <li><a href='build-script.html'>Build Scripts</a></li>
                <li><a href='config.html'>Configuration</a></li>
                <li><a href='pkgid-spec.html'>Package ID specs</a></li>
            </ul>
        </div>
    </div>
</div>

<main>


    <h1 class="title">Guide</h1>
    <p>Welcome to the Cargo guide. This guide will give you all that you need to know
about how to use Cargo to develop Rust projects.</p>

<h1 id="why-cargo-exists" class='section-header'><a
                           href="#why-cargo-exists">Why Cargo exists</a></h1>
<p>Cargo is a tool that allows Rust projects to declare their various
dependencies, and ensure that you&#39;ll always get a repeatable build.</p>

<p>To accomplish this goal, Cargo does four things:</p>

<ul>
<li>Introduces two metadata files with various bits of project information.</li>
<li>Fetches and builds your project&#39;s dependencies.</li>
<li>Invokes <code>rustc</code> or another build tool with the correct parameters to build your project.</li>
<li>Introduces conventions, making working with Rust projects easier.</li>
</ul>

<h1 id="converting-to-cargo" class='section-header'><a
                           href="#converting-to-cargo">Converting to Cargo</a></h1>
<p>You can convert an existing Rust project to use Cargo. You&#39;ll have to create a
<code>Cargo.toml</code> file with all of your dependencies, and move your source files and
test files into the places where Cargo expects them to be. See the <a href="manifest.html">manifest
description</a> and the &quot;Cargo Conventions&quot; section below for more
details.</p>

<h1 id="creating-a-new-project" class='section-header'><a
                           href="#creating-a-new-project">Creating A New Project</a></h1>
<p>To start a new project with Cargo, use <code>cargo new</code>:</p>

<pre><code class="language-shell">$ cargo new hello_world --bin
</code></pre>

<p>We&#39;re passing <code>--bin</code> because we&#39;re making a binary program: if we
were making a library, we&#39;d leave it off. If you&#39;d like to not initialize a new
git repository as well (the default), you can also pass <code>--vcs none</code>.</p>

<p>Let&#39;s check out what Cargo has generated for us:</p>

<pre><code class="language-shell">$ cd hello_world
$ tree .
.
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files
</code></pre>

<p>If we had just used <code>cargo new hello_world</code> without the <code>--bin</code> flag, then the
we would have a <code>lib.rs</code> instead of a <code>main.rs</code>. For now, however, this is all
we need to get started. First, let&#39;s check out <code>Cargo.toml</code>:</p>

<pre><code class="language-toml">[package]

name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
</code></pre>

<p>This is called a <strong>manifest</strong>, and it contains all of the metadata that Cargo
needs to compile your project.</p>

<p>Here&#39;s what&#39;s in <code>src/main.rs</code>:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Hello, world!&quot;</span>);
}
</pre>

<p>Cargo generated a &#39;hello world&#39; for us. Let&#39;s compile it:</p>

<pre><code class="language-shell"><span class="gp">$</span> cargo build
<span style="font-weight: bold"
class="s1">   Compiling</span> hello_world v0.0.1 (file:///path/to/project/hello_world)</code></pre>

<p>And then run it:</p>

<pre><code class="language-shell">$ ./target/hello_world
Hello, world!
</code></pre>

<p>We can also use <code>cargo run</code> to compile and then run it, all in one step:</p>

<pre><code class="language-shell"><span class="gp">$</span> cargo run
<span style="font-weight: bold"
class="s1">     Fresh</span> hello_world v0.0.1 (file:///path/to/project/hello_world)
<span style="font-weight: bold"
class="s1">   Running</span> `target/hello_world`
Hello, world!</code></pre>

<p>You&#39;ll now notice a new file, <code>Cargo.lock</code>. It contains information about our
dependencies. Since we don&#39;t have any yet, it&#39;s not very interesting.</p>

<h2 id="adding-a-dependency" class='section-header'><a
                           href="#adding-a-dependency">Adding a dependency</a></h2>
<p>It&#39;s quite simple to add a dependency. Simply add it to your <code>Cargo.toml</code> file:</p>

<pre><code class="language-toml">[dependencies]
time = &quot;0.1.12&quot;
</code></pre>

<p>Re-run <code>cargo build</code> to download the dependencies and build your source with the new dependencies.</p>

<h1 id="working-on-an-existing-cargo-project" class='section-header'><a
                           href="#working-on-an-existing-cargo-project">Working on an existing Cargo project</a></h1>
<p>If you download an existing project that uses Cargo, it&#39;s really easy
to get going.</p>

<p>First, get the project from somewhere. In this example, we&#39;ll use <code>color-rs</code>:</p>

<pre><code class="language-sh">$ git clone https://github.com/bjz/color-rs.git
$ cd color-rs
</code></pre>

<p>To build, just use <code>cargo build</code>:</p>

<pre><code class="language-shell"><span class="gp">$</span> cargo build
<span style="font-weight: bold" class="s1">   Compiling</span> color v0.0.1 (file:///path/to/project/color-rs)</code></pre>

<p>This will fetch all of the dependencies and then build them, along with the
project.</p>

<h1 id="adding-dependencies" class='section-header'><a
                           href="#adding-dependencies">Adding Dependencies</a></h1>
<p>To depend on a library, add it to your <code>Cargo.toml</code>.</p>

<pre><code class="language-toml">[package]

name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies.color]

git = &quot;https://github.com/bjz/color-rs.git&quot;
</code></pre>

<p>You added the <code>color</code> library, which provides simple conversions
between different color types.</p>

<p>Now, you can pull in that library using <code>extern crate</code> in
<code>main.rs</code>.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>color</span>;

<span class='kw'>use</span> <span class='ident'>color</span>::{<span class='ident'>Rgb</span>, <span class='ident'>ToHsv</span>};

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Converting RGB to HSV!&quot;</span>);
    <span class='kw'>let</span> <span class='ident'>red</span> <span class='op'>=</span> <span class='ident'>Rgb</span>::<span class='ident'>new</span>(<span class='number'>255u8</span>, <span class='number'>0</span>, <span class='number'>0</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;HSV: {:?}&quot;</span>, <span class='ident'>red</span>.<span class='ident'>to_hsv</span>::<span class='op'>&lt;</span><span class='ident'>f32</span><span class='op'>&gt;</span>());
}
</pre>

<p>Let&#39;s tell Cargo to fetch this new dependency and update the <code>Cargo.lock</code>:</p>

<pre><code class="language-shell"><span class="gp">$</span> cargo update -p color
<span style="font-weight: bold" class="s1">    Updating</span> git repository `https://github.com/bjz/color-rs.git`</code></pre>

<p>Compile it:</p>

<pre><code class="language-shell"><span class="gp">$</span> cargo run
<span style="font-weight: bold" class="s1">   Compiling</span> color v0.0.1 (https://github.com/bjz/color-rs.git#bf739419)
<span style="font-weight: bold" class="s1">   Compiling</span> hello_world v0.0.1 (file:///path/to/project/hello_world)
<span style="font-weight: bold" class="s1">     Running</span> `target/hello_world`
Converting RGB to HSV!
HSV: HSV { h: 0, s: 1, v: 1 }</code></pre>

<p>We just specified a <code>git</code> repository for our dependency, but our <code>Cargo.lock</code>
contains the exact information about which revision we used:</p>

<pre><code class="language-toml">[root]
name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
dependencies = [
 &quot;color 0.0.1 (git+https://github.com/bjz/color-rs.git#bf739419e2d31050615c1ba1a395b474269a4b98)&quot;,
]

[[package]]
name = &quot;color&quot;
version = &quot;0.0.1&quot;
source = &quot;git+https://github.com/bjz/color-rs.git#bf739419e2d31050615c1ba1a395b474269a4b98&quot;

</code></pre>

<p>Now, if <code>color-rs</code> gets updated, we will still build with the same revision, until
we choose to <code>cargo update</code> again.</p>

<h1 id="cargo-conventions" class='section-header'><a
                           href="#cargo-conventions">Cargo Conventions</a></h1>
<p>Cargo uses conventions to make it easy to dive into a new Cargo project. Here
are the conventions that Cargo uses:</p>

<ul>
<li><code>Cargo.toml</code> and <code>Cargo.lock</code> are stored in the root of your project.</li>
<li>Source code goes in the <code>src</code> directory.</li>
<li>External tests go in the <code>tests</code> directory.</li>
<li>The default executable file is <code>src/main.rs</code>.</li>
<li>Other executables can be placed in <code>src/bin/*.rs</code>.</li>
<li>The default library file is <code>src/lib.rs</code>.</li>
</ul>

<h1 id="cargo.toml-vs-cargo.lock" class='section-header'><a
                           href="#cargo.toml-vs-cargo.lock">Cargo.toml vs Cargo.lock</a></h1>
<p><code>Cargo.toml</code> and <code>Cargo.lock</code> serve two different purposes. Before we talk
about them, here&#39;s a summary:</p>

<ul>
<li><code>Cargo.toml</code> is about describing your dependencies in a broad sense, and is written by you.</li>
<li><code>Cargo.lock</code> contains exact information about your dependencies, and is maintained by Cargo.</li>
<li>If you&#39;re building a library, put <code>Cargo.lock</code> in your <code>.gitignore</code>.</li>
<li>If you&#39;re building an executable, check <code>Cargo.lock</code> into <code>git</code>.</li>
</ul>

<p>Let&#39;s dig in a little bit more.</p>

<p><code>Cargo.toml</code> is a <strong>manifest</strong> file. In the manifest, we can specify a bunch of
different metadata about our project. For example, we can say that we depend
on another project:</p>

<pre><code class="language-toml">[package]

name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies.color]

git = &quot;https://github.com/bjz/color-rs.git&quot;
</code></pre>

<p>This project has a single dependency, on the <code>color</code> library. We&#39;ve stated in
this case that we&#39;re relying on a particular Git repository that lives on
GitHub. Since we haven&#39;t specified any other information, Cargo assumes that
we intend to use the latest commit on the <code>master</code> branch to build our project.</p>

<p>Sound good? Well, there&#39;s one problem: If you build this project today, and
then you send a copy to me, and I build this project tomorrow, something bad
could happen. <code>bjz</code> could update <code>color-rs</code> in the meantime, and my build would
include this commit, while yours would not. Therefore, we would get different
builds. This would be bad, because we want reproducible builds.</p>

<p>We could fix this problem by putting a <code>rev</code> line in our <code>Cargo.toml</code>:</p>

<pre><code class="language-toml">[dependencies.color]

git = &quot;https://github.com/bjz/color-rs.git&quot;
rev = &quot;bf739419e2d31050615c1ba1a395b474269a4&quot;
</code></pre>

<p>Now, our builds will be the same. But, there&#39;s a big drawback: now we have to
manually think about SHA-1s every time we want to update our library. This is
both tedious and error prone.</p>

<p>Enter the <code>Cargo.lock</code>. Because of its existence, we don&#39;t need to manually
keep track of the exact revisions: Cargo will do it for us. When we have a
manifest like this:</p>

<pre><code class="language-toml">[package]

name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies.color]

git = &quot;https://github.com/bjz/color-rs.git&quot;
</code></pre>

<p>Cargo will take the latest commit, and write that information out into our
<code>Cargo.lock</code> when we build for the first time. That file will look like this:</p>

<pre><code class="language-toml">[root]
name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
dependencies = [
 &quot;color 0.0.1 (git+https://github.com/bjz/color-rs.git#bf739419e2d31050615c1ba1a395b474269a4b98)&quot;,
]

[[package]]
name = &quot;color&quot;
version = &quot;0.0.1&quot;
source = &quot;git+https://github.com/bjz/color-rs.git#bf739419e2d31050615c1ba1a395b474269a4b98&quot;

</code></pre>

<p>You can see that there&#39;s a lot more information here, including the exact
revision we used to build. Now, when you give your project to someone else,
they&#39;ll use the exact same SHA, even though we didn&#39;t specify it in our
<code>Cargo.toml</code>.</p>

<p>When we&#39;re ready to opt in to a new version of the library, Cargo can
re-calculate the dependencies, and update things for us:</p>

<pre><code class="language-shell">$ cargo update           # updates all dependencies
$ cargo update -p color  # updates just &#39;color&#39;
</code></pre>

<p>This will write out a new <code>Cargo.lock</code> with the new version information. Note
that the argument to <code>cargo update</code> is actually a
<a href="pkgid-spec.html">Package ID Specification</a> and <code>color</code> is just a short
specification.</p>

<h1 id="overriding-dependencies" class='section-header'><a
                           href="#overriding-dependencies">Overriding Dependencies</a></h1>
<p>Sometimes, you may want to override one of Cargo&#39;s dependencies. For example,
let&#39;s say you&#39;re working on a project, <code>conduit-static</code>, which depends on
the package <code>conduit</code>. You find a bug in <code>conduit</code>, and you want to write a
patch. Here&#39;s what <code>conduit-static</code>&#39;s <code>Cargo.toml</code> looks like:</p>

<pre><code class="language-toml">[package]

name = &quot;conduit-static&quot;
version = &quot;0.0.1&quot;
authors = [&quot;Yehuda Katz &lt;wycats@example.com&gt;&quot;]

[dependencies.conduit]

git = &quot;https://github.com/conduit-rust/conduit.git&quot;
</code></pre>

<p>You check out a local copy of <code>conduit</code>, let&#39;s say in your <code>~/src</code> directory:</p>

<pre><code class="language-shell">$ cd ~/src
$ git clone https://github.com/conduit-rust/conduit.git
</code></pre>

<p>You&#39;d like to have <code>conduit-static</code> use your local version of <code>conduit</code>,
rather than the one on GitHub, while you fix the bug.</p>

<p>Cargo solves this problem by allowing you to have a local configuration
that specifies an <strong>override</strong>. If Cargo finds this configuration when
building your package, it will use the override on your local machine
instead of the source specified in your <code>Cargo.toml</code>.</p>

<p>Cargo looks for a directory named <code>.cargo</code> up the directory hierarchy of
your project. If your project is in <code>/path/to/project/conduit-static</code>,
it will search for a <code>.cargo</code> in:</p>

<ul>
<li><code>/path/to/project/conduit-static</code></li>
<li><code>/path/to/project</code></li>
<li><code>/path/to</code></li>
<li><code>/path</code></li>
<li><code>/</code></li>
</ul>

<p>This allows you to specify your overrides in a parent directory that
includes commonly used packages that you work on locally, and share them
with all projects.</p>

<p>To specify overrides, create a <code>.cargo/config</code> file in some ancestor of
your project&#39;s directory (common places to put it is in the root of
your code directory or in your home directory).</p>

<p>Inside that file, put this:</p>

<pre><code class="language-toml">paths = [&quot;/path/to/project/conduit&quot;]
</code></pre>

<p>This array should be filled with directories that contain a <code>Cargo.toml</code>. In
this instance, we&#39;re just adding <code>conduit</code>, so it will be the only one that&#39;s
overridden.</p>

<p>More information about local configuration can be found in the <a href="config.html">configuration
documentation</a>.</p>

<h1 id="tests" class='section-header'><a
                           href="#tests">Tests</a></h1>
<p>Cargo can run your tests with the <code>cargo test</code> command. Cargo runs tests in two
places: in each of your <code>src</code> files, and any tests in <code>tests/</code>. Tests
in your <code>src</code> files should be unit tests, and tests in <code>tests/</code> should be
integration-style tests. As such, you&#39;ll need to import your crates into
the files in <code>tests</code>.</p>

<p>To run your tests, just run <code>cargo test</code>:</p>

<pre><code class="language-shell"><span class="gp">$</span> cargo test
<span style="font-weight: bold"
class="s1">   Compiling</span> color v0.0.1 (https://github.com/bjz/color-rs.git#bf739419)
<span style="font-weight: bold"
class="s1">   Compiling</span> hello_world v0.0.1 (file:///path/to/project/hello_world)
<span style="font-weight: bold"
class="s1">     Running</span> target/test/hello_world-9c2b65bbb79eabce

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>

<p>Of course, if your project has tests, you&#39;ll see more output, with the
correct number of tests.</p>

<h1 id="path-dependencies" class='section-header'><a
                           href="#path-dependencies">Path Dependencies</a></h1>
<p>Over time our <code>hello_world</code> project has grown significantly in size! It&#39;s gotten
to the point that we probably want to split out a separate crate for others to
use. To do this Cargo supports <strong>path dependencies</strong> which are typically
sub-crates that live within one repository. Let&#39;s start off by making a new
crate inside of our <code>hello_world</code> project:</p>

<pre><code class="language-shell"># inside of hello_world/
$ cargo new hello_utils
</code></pre>

<p>This will create a new folder <code>hello_utils</code> inside of which a <code>Cargo.toml</code> and
<code>src</code> folder are ready to be configured. In order to tell Cargo about this, open
up <code>hello_world/Cargo.toml</code> and add these lines:</p>

<pre><code class="language-toml">[dependencies.hello_utils]
path = &quot;hello_utils&quot;
</code></pre>

<p>This tells Cargo that we depend on a crate called <code>hello_utils</code> which is found
in the <code>hello_utils</code> folder (relative to the <code>Cargo.toml</code> it&#39;s written in).</p>

<p>And that&#39;s it! The next <code>cargo build</code> will automatically build <code>hello_utils</code> and
all of its own dependencies, and others can also start using the crate as well.</p>

<h2 id="travis-ci" class='section-header'><a
                           href="#travis-ci">Travis-CI</a></h2>
<p>To test your project on Travis-CI, here is a sample <code>.travis.yml</code> file:</p>
<pre id='rust-example-rendered' class='rust '>
<span class='ident'>language</span>: <span class='ident'>rust</span>
</pre>

    <script type="text/javascript">
        window.playgroundUrl = "";
    </script>
    </main>
<footer>
<a href='index.html'>Install</a>
<span class='sep'>|</span>
<a href='index.html'>Getting Started</a>
<span class='sep'>|</span>
<a href='guide.html'>Guide</a>
</footer>

<script type='text/javascript' src='javascripts/prism.js'></script>
<script type='text/javascript' src='javascripts/all.js'></script>


</body>
</html>